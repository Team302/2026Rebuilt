//====================================================================================================================================================
// Copyright 2026 Lake Orion Robotics FIRST Team 302
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
// OR OTHER DEALINGS IN THE SOFTWARE.
//====================================================================================================================================================
// This file was automatically generated by the Team 302 code generator version 20.26.00.00
// Generated on Monday, January 19, 2026 7:44:30 PM

#include <string>

// FRC Includes
#include <networktables/NetworkTableInstance.h>
#include <frc/Timer.h>

#include "Intake.h"
#include "utils/logging/debug/Logger.h"
#include "utils/PeriodicLooper.h"
#include "state/RobotState.h"
#include "utils/DragonPower.h"

#include "ctre/phoenix6/TalonFX.hpp"
#include "ctre/phoenix6/controls/Follower.hpp"
#include "ctre/phoenix6/configs/Configuration.hpp"
#include "frc/Solenoid.h"
#include "utils/logging/signals/DragonDataLogger.h"
#include <frc/DigitalInput.h>
#include <frc/filter/Debouncer.h>
#include "mechanisms/Intake/OffState.h"
#include "mechanisms/Intake/IntakeState.h"
#include "mechanisms/Intake/ExpelState.h"
#include "mechanisms/Intake/LaunchState.h"
#include "mechanisms/Intake/EmptyHopperState.h"

using ctre::phoenix6::configs::Slot0Configs;
using ctre::phoenix6::configs::Slot1Configs;
using ctre::phoenix6::configs::TalonFXConfiguration;
using ctre::phoenix6::signals::FeedbackSensorSourceValue;
using ctre::phoenix6::signals::ForwardLimitSourceValue;
using ctre::phoenix6::signals::ForwardLimitTypeValue;
using ctre::phoenix6::signals::GravityTypeValue;
using ctre::phoenix6::signals::InvertedValue;
using ctre::phoenix6::signals::NeutralModeValue;
using ctre::phoenix6::signals::ReverseLimitSourceValue;
using ctre::phoenix6::signals::ReverseLimitTypeValue;
using ctre::phoenix6::signals::StaticFeedforwardSignValue;

using std::string;
using namespace IntakeStates;

void Intake::CreateAndRegisterStates()
{
	OffState *OffStateInst = new OffState(string("Off"), 0, this, m_activeRobotId);
	AddToStateVector(OffStateInst);

	IntakeState *IntakeStateInst = new IntakeState(string("Intake"), 1, this, m_activeRobotId);
	AddToStateVector(IntakeStateInst);

	ExpelState *ExpelStateInst = new ExpelState(string("Expel"), 2, this, m_activeRobotId);
	AddToStateVector(ExpelStateInst);

	LaunchState *LaunchStateInst = new LaunchState(string("Launch"), 3, this, m_activeRobotId);
	AddToStateVector(LaunchStateInst);

	EmptyHopperState *EmptyHopperStateInst = new EmptyHopperState(string("EmptyHopper"), 4, this, m_activeRobotId);
	AddToStateVector(EmptyHopperStateInst);

	OffStateInst->RegisterTransitionState(IntakeStateInst);
	OffStateInst->RegisterTransitionState(ExpelStateInst);
	OffStateInst->RegisterTransitionState(LaunchStateInst);
	OffStateInst->RegisterTransitionState(EmptyHopperStateInst);
	IntakeStateInst->RegisterTransitionState(OffStateInst);
	IntakeStateInst->RegisterTransitionState(LaunchStateInst);
	IntakeStateInst->RegisterTransitionState(EmptyHopperStateInst);
	ExpelStateInst->RegisterTransitionState(OffStateInst);
	ExpelStateInst->RegisterTransitionState(LaunchStateInst);
	ExpelStateInst->RegisterTransitionState(EmptyHopperStateInst);
	LaunchStateInst->RegisterTransitionState(OffStateInst);
	LaunchStateInst->RegisterTransitionState(IntakeStateInst);
	LaunchStateInst->RegisterTransitionState(ExpelStateInst);
	LaunchStateInst->RegisterTransitionState(EmptyHopperStateInst);
	EmptyHopperStateInst->RegisterTransitionState(OffStateInst);
	EmptyHopperStateInst->RegisterTransitionState(IntakeStateInst);
}

Intake::Intake(RobotIdentifier activeRobotId) : BaseMech(MechanismTypes::MECHANISM_TYPE::INTAKE, std::string("Intake")),
												m_activeRobotId(activeRobotId),
												m_stateMap()
{
	PeriodicLooper::GetInstance()->RegisterAll(this);
	// InitializeLogging();
}

/* void Intake::InitializeLogging()
 {
	wpi::log::DataLog &log = frc::DataLogManager::GetLog();

	 m_IntakeTotalEnergyLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Intake/TotalEnergy");
m_IntakeTotalEnergyLogEntry.Append(0.0);
m_IntakeTotalWattHoursLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Intake/TotalWattHours");
m_IntakeTotalWattHoursLogEntry.Append(0.0);
m_IntakeLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Intake/IntakePosition");
m_IntakeLogEntry.Append(0.0);
m_IntakeTargetLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Intake/IntakeTarget");
m_IntakeTargetLogEntry.Append(0.0);
m_IntakePowerLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Intake/IntakePower");
m_IntakePowerLogEntry.Append(0.0);
m_IntakeEnergyLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Intake/IntakeEnergy");
m_IntakeEnergyLogEntry.Append(0.0);
m_HopperLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Intake/HopperPosition");
m_HopperLogEntry.Append(0.0);
m_HopperTargetLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Intake/HopperTarget");
m_HopperTargetLogEntry.Append(0.0);
m_HopperPowerLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Intake/HopperPower");
m_HopperPowerLogEntry.Append(0.0);
m_HopperEnergyLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Intake/HopperEnergy");
m_HopperEnergyLogEntry.Append(0.0);
m_IsIntakeExtendedLogEntry = wpi::log::BooleanLogEntry(log, "mechanisms/Intake/IsIntakeExtended");
m_IsIntakeExtendedLogEntry.Append(false);

m_IntakeStateLogEntry = wpi::log::IntegerLogEntry(log, "mechanisms/Intake/State");
m_IntakeStateLogEntry.Append(0);
 }*/

std::map<std::string, Intake::STATE_NAMES>
	Intake::stringToSTATE_NAMESEnumMap{
		{"STATE_OFF", Intake::STATE_NAMES::STATE_OFF},
		{"STATE_INTAKE", Intake::STATE_NAMES::STATE_INTAKE},
		{"STATE_EXPEL", Intake::STATE_NAMES::STATE_EXPEL},
		{"STATE_LAUNCH", Intake::STATE_NAMES::STATE_LAUNCH},
		{"STATE_EMPTY_HOPPER", Intake::STATE_NAMES::STATE_EMPTY_HOPPER},
	};

void Intake::CreateCompBot302()
{
	m_ntName = "Intake";
	m_Intake = new ctre::phoenix6::hardware::TalonFX(4, ctre::phoenix6::CANBus("canivore"));
	// m_Hopper = new ctre::phoenix6::hardware::TalonFX(0, ctre::phoenix6::CANBus("canivore"));

	m_Extender = new frc::Solenoid(1, frc::PneumaticsModuleType::REVPH, 0);

	m_IsIntakeExtended = new frc::DigitalInput(0);
	m_IsIntakeExtendedIsInverted = false;

	m_PercentOut = new ControlData(
		ControlModes::CONTROL_TYPE::PERCENT_OUTPUT,		  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PercentOut",									  // std::string indentifier
		0,												  // double proportional
		0,												  // double integral
		0,												  // double derivative
		0,												  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::DUTY_CYCLE,				 // FEEDFORWARD_TYPE feedforwadType
		0,														 // double integralZone
		0,														 // double maxAcceleration
		0,														 // double cruiseVelocity
		0,														 // double peakValue
		0,														 // double nominalValue
		false,													 // bool enableFOC
		ControlData::GravityTypeValue::Elevator_Static,			 // Gravity type
		ControlData::StaticFeedforwardSignValue::UseVelocitySign // Static feedforward sign
	);

	ReadConstants("Intake.xml", 302);
}

void Intake::InitializeCompBot302()
{
	InitializeTalonFXIntakeCompBot302();
	// InitializeTalonFXHopperCompBot302();
}
void Intake::InitializeTalonFXIntakeCompBot302()
{
	TalonFXConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(100);
	configs.CurrentLimits.StatorCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(70);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(35);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.ClosedLoopRamps.TorqueClosedLoopRampPeriod = units::time::second_t(0.25);

	configs.HardwareLimitSwitch.ForwardLimitEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::Clockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Coast;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue::RotorSensor;
	configs.Feedback.SensorToMechanismRatio = 1;

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_Intake->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_Intake", "m_Intake Status", status.GetName());
}

void Intake::InitializeTalonFXHopperCompBot302()
{
	TalonFXConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(100);
	configs.CurrentLimits.StatorCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(70);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(35);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.ClosedLoopRamps.TorqueClosedLoopRampPeriod = units::time::second_t(0.25);

	configs.HardwareLimitSwitch.ForwardLimitEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::CounterClockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Coast;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue::RotorSensor;
	configs.Feedback.SensorToMechanismRatio = 1;

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_Hopper->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_Hopper", "m_Hopper Status", status.GetName());
}

void Intake::SetCurrentState(int state, bool run)
{
	StateMgr::SetCurrentState(state, run);
}

void Intake::RunCommonTasks()
{
	// This function is called once per loop before the current state Run()
	Cyclic();
}

/// @brief  Set the control constants (e.g. PIDF values).
/// @param [in] ControlData*                                   pid:  the control constants
/// @return void
void Intake::SetControlConstants(RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, int slot, ControlData pid)
{
}

/// @brief update the output to the mechanism using the current controller and target value(s)
/// @return void
void Intake::Update()
{
	m_Intake->SetControl(*m_IntakeActiveTarget);
	// m_Hopper->SetControl(*m_HopperActiveTarget);
}

void Intake::Cyclic()
{
	Update();

	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, m_ntName, "State", GetCurrentState());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, m_ntName, "IsIntakeExtended", GetIsIntakeExtendedState());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, m_ntName, "IntakePercentOut", m_IntakePercentOut.Output.value());
}

ControlData *Intake::GetControlData(string name)
{
	if (name.compare("PercentOut") == 0)
		return m_PercentOut;

	return nullptr;
}

/* void Intake::DataLog(uint64_t timestamp)
{
   auto currTime = m_powerTimer.Get();
LogIntake(timestamp, m_Intake->GetPosition().GetValueAsDouble());
auto IntakePower = DragonPower::CalcPowerEnergy(currTime, m_Intake->GetSupplyVoltage().GetValueAsDouble(), m_Intake->GetSupplyCurrent().GetValueAsDouble());
m_power = get<0>(IntakePower);
m_energy = get<1>(IntakePower);
m_totalEnergy += m_energy;
LogIntakePower(timestamp, m_power);
LogIntakeEnergy(timestamp, m_energy);
LogHopper(timestamp, m_Hopper->GetPosition().GetValueAsDouble());
auto HopperPower = DragonPower::CalcPowerEnergy(currTime, m_Hopper->GetSupplyVoltage().GetValueAsDouble(), m_Hopper->GetSupplyCurrent().GetValueAsDouble());
m_power = get<0>(HopperPower);
m_energy = get<1>(HopperPower);
m_totalEnergy += m_energy;
LogHopperPower(timestamp, m_power);
LogHopperEnergy(timestamp, m_energy);
LogIsIntakeExtended(timestamp, GetIsIntakeExtended());
LogIntakeState(timestamp, GetCurrentState());
m_totalWattHours += DragonPower::ConvertEnergyToWattHours(m_totalEnergy);
LogIntakeTotalEnergy(timestamp, m_totalEnergy);
LogIntakeTotalWattHours(timestamp, m_totalWattHours);
m_powerTimer.Reset();
m_powerTimer.Start();
 }*/