//====================================================================================================================================================
// Copyright 2026 Lake Orion Robotics FIRST Team 302
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
// OR OTHER DEALINGS IN THE SOFTWARE.
//====================================================================================================================================================
// This file was automatically generated by the Team 302 code generator version 20.26.00.00
// Generated on Thursday, January 22, 2026 11:43:04 PM

#include <string>

// FRC Includes
#include <networktables/NetworkTableInstance.h>
#include <frc/Timer.h>

#include "Launcher.h"
#include "utils/logging/debug/Logger.h"
#include "utils/PeriodicLooper.h"
#include "state/RobotState.h"
#include "utils/DragonPower.h"

#include "ctre/phoenix6/TalonFX.hpp"
#include "ctre/phoenix6/controls/Follower.hpp"
#include "ctre/phoenix6/configs/Configuration.hpp"
#include "ctre/phoenix6/TalonFXS.hpp"
#include "mechanisms/Launcher/OffState.h"
#include "mechanisms/Launcher/InitializeState.h"
#include "mechanisms/Launcher/IdleState.h"
#include "mechanisms/Launcher/PrepareToLaunchState.h"
#include "mechanisms/Launcher/LaunchState.h"
#include "mechanisms/Launcher/EmptyHopperState.h"
#include "mechanisms/Launcher/ClimbState.h"
#include "mechanisms/Launcher/LauncherTuningState.h"
#include "mechanisms/Launcher/ManualLaunchState.h"

#include "teleopcontrol/TeleopControl.h"
#include "utils/InterpolateUtils.h"
#include "units/math.h"

using ctre::phoenix6::configs::Slot0Configs;
using ctre::phoenix6::configs::Slot1Configs;
using ctre::phoenix6::configs::TalonFXConfiguration;
using ctre::phoenix6::configs::TalonFXSConfiguration;
using ctre::phoenix6::signals::FeedbackSensorSourceValue;
using ctre::phoenix6::signals::ForwardLimitSourceValue;
using ctre::phoenix6::signals::ForwardLimitTypeValue;
using ctre::phoenix6::signals::GravityTypeValue;
using ctre::phoenix6::signals::InvertedValue;
using ctre::phoenix6::signals::MotorArrangementValue;
using ctre::phoenix6::signals::NeutralModeValue;
using ctre::phoenix6::signals::ReverseLimitSourceValue;
using ctre::phoenix6::signals::ReverseLimitTypeValue;
using ctre::phoenix6::signals::StaticFeedforwardSignValue;

using std::string;
using namespace LauncherStates;

namespace
{
	// Common current limit configuration used by all motors
	struct CurrentLimitConfig
	{
		units::current::ampere_t statorLimit = units::current::ampere_t(100);
		units::current::ampere_t supplyLimit = units::current::ampere_t(70);
		units::current::ampere_t supplyLowerLimit = units::current::ampere_t(35);
		units::time::second_t supplyLowerTime = units::time::second_t(0);
	};

	// Common voltage configuration used by all motors
	struct VoltageConfig
	{
		units::voltage::volt_t peakForward = units::voltage::volt_t(11.0);
		units::voltage::volt_t peakReverse = units::voltage::volt_t(-11.0);
		units::time::second_t rampPeriod = units::time::second_t(0.25);
	};

	template <typename ConfigType>
	void ApplyCurrentLimits(ConfigType &configs, const CurrentLimitConfig &limits = {})
	{
		configs.CurrentLimits.StatorCurrentLimit = limits.statorLimit;
		configs.CurrentLimits.StatorCurrentLimitEnable = true;
		configs.CurrentLimits.SupplyCurrentLimit = limits.supplyLimit;
		configs.CurrentLimits.SupplyCurrentLimitEnable = true;
		configs.CurrentLimits.SupplyCurrentLowerLimit = limits.supplyLowerLimit;
		configs.CurrentLimits.SupplyCurrentLowerTime = limits.supplyLowerTime;
	}

	template <typename ConfigType>
	void ApplyVoltageConfig(ConfigType &configs, const VoltageConfig &voltage = {})
	{
		configs.Voltage.PeakForwardVoltage = voltage.peakForward;
		configs.Voltage.PeakReverseVoltage = voltage.peakReverse;
		configs.ClosedLoopRamps.TorqueClosedLoopRampPeriod = voltage.rampPeriod;
	}

	template <typename ConfigType>
	void ApplyDisabledLimitSwitches(ConfigType &configs)
	{
		configs.HardwareLimitSwitch.ForwardLimitEnable = false;
		configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
		configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = false;
		configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(0);
		configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
		configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

		configs.HardwareLimitSwitch.ReverseLimitEnable = false;
		configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
		configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = false;
		configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
		configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
		configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;
	}

	void ApplyDefaultMotorOutput(TalonFXConfiguration &configs, InvertedValue inversion, NeutralModeValue neutralMode)
	{
		configs.MotorOutput.Inverted = inversion;
		configs.MotorOutput.NeutralMode = neutralMode;
		configs.MotorOutput.PeakForwardDutyCycle = 1;
		configs.MotorOutput.PeakReverseDutyCycle = -1;
		configs.MotorOutput.DutyCycleNeutralDeadband = 0;
	}

	void ApplyDefaultMotorOutput(TalonFXSConfiguration &configs, InvertedValue inversion, NeutralModeValue neutralMode)
	{
		configs.MotorOutput.Inverted = inversion;
		configs.MotorOutput.NeutralMode = neutralMode;
		configs.MotorOutput.PeakForwardDutyCycle = 1;
		configs.MotorOutput.PeakReverseDutyCycle = -1;
		configs.MotorOutput.DutyCycleNeutralDeadband = 0;
	}

	void ApplyDefaultFeedback(TalonFXConfiguration &configs)
	{
		configs.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue::RotorSensor;
		configs.Feedback.SensorToMechanismRatio = 1;
	}

	template <typename ConfigType>
	void ApplySlot0FromControlData(ConfigType &configs, ControlData *controlData)
	{
		configs.Slot0.kI = controlData->GetI();
		configs.Slot0.kD = controlData->GetD();
		configs.Slot0.kG = controlData->GetF();
		configs.Slot0.kS = controlData->GetS();
		configs.Slot0.kV = controlData->GetV();
		configs.Slot0.kP = controlData->GetP();
		configs.Slot0.kA = controlData->GetA();
		configs.Slot0.GravityType = controlData->GetGravityType();
		configs.Slot0.StaticFeedforwardSign = controlData->GetStaticFeedforwardSign();
	}

	template <typename MotorType, typename ConfigType>
	bool ApplyConfigWithRetry(MotorType *motor, ConfigType &configs, const char *motorName)
	{
		ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
		for (int i = 0; i < 5; ++i)
		{
			status = motor->GetConfigurator().Apply(configs, units::time::second_t(0.25));
			if (status.IsOK())
				return true;
		}
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, motorName, string(motorName) + " Status", status.GetName());
		return false;
	}

	ControlData *CreateZeroControlData(ControlModes::CONTROL_TYPE type, const char *identifier)
	{
		return new ControlData(
			type,
			ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER,
			identifier,
			0, 0, 0, 0, 0, 0, 0,
			ControlData::FEEDFORWARD_TYPE::DUTY_CYCLE,
			0, 0, 0, 0, 0, false,
			ControlData::GravityTypeValue::Elevator_Static,
			ControlData::StaticFeedforwardSignValue::UseVelocitySign);
	}
} // anonymous namespace

void Launcher::CreateAndRegisterStates()
{
	OffState *OffStateInst = new OffState(string("Off"), 0, this, m_activeRobotId);
	AddToStateVector(OffStateInst);

	InitializeState *InitializeStateInst = new InitializeState(string("Initialize"), 1, this, m_activeRobotId);
	AddToStateVector(InitializeStateInst);

	IdleState *IdleStateInst = new IdleState(string("Idle"), 2, this, m_activeRobotId);
	AddToStateVector(IdleStateInst);

	PrepareToLaunchState *PrepareToLaunchStateInst = new PrepareToLaunchState(string("PrepareToLaunch"), 3, this, m_activeRobotId);
	AddToStateVector(PrepareToLaunchStateInst);

	LaunchState *LaunchStateInst = new LaunchState(string("Launch"), 4, this, m_activeRobotId);
	AddToStateVector(LaunchStateInst);

	EmptyHopperState *EmptyHopperStateInst = new EmptyHopperState(string("EmptyHopper"), 5, this, m_activeRobotId);
	AddToStateVector(EmptyHopperStateInst);

	ClimbState *ClimbStateInst = new ClimbState(string("Climb"), 6, this, m_activeRobotId);
	AddToStateVector(ClimbStateInst);

	LauncherTuningState *LauncherTuningStateInst = new LauncherTuningState(string("LauncherTuning"), 7, this, m_activeRobotId);
	AddToStateVector(LauncherTuningStateInst);

	ManualLaunchState *ManualLaunchStateInst = new ManualLaunchState(string("ManualLaunch"), 8, this, m_activeRobotId);
	AddToStateVector(ManualLaunchStateInst);

	OffStateInst->RegisterTransitionState(InitializeStateInst);
	InitializeStateInst->RegisterTransitionState(IdleStateInst);
	IdleStateInst->RegisterTransitionState(OffStateInst);
	IdleStateInst->RegisterTransitionState(PrepareToLaunchStateInst);
	IdleStateInst->RegisterTransitionState(EmptyHopperStateInst);
	IdleStateInst->RegisterTransitionState(ClimbStateInst);
	IdleStateInst->RegisterTransitionState(LauncherTuningStateInst);
	IdleStateInst->RegisterTransitionState(ManualLaunchStateInst);
	PrepareToLaunchStateInst->RegisterTransitionState(OffStateInst);
	PrepareToLaunchStateInst->RegisterTransitionState(IdleStateInst);
	PrepareToLaunchStateInst->RegisterTransitionState(LaunchStateInst);
	PrepareToLaunchStateInst->RegisterTransitionState(EmptyHopperStateInst);
	PrepareToLaunchStateInst->RegisterTransitionState(ClimbStateInst);
	LaunchStateInst->RegisterTransitionState(OffStateInst);
	LaunchStateInst->RegisterTransitionState(IdleStateInst);
	LaunchStateInst->RegisterTransitionState(PrepareToLaunchStateInst);
	EmptyHopperStateInst->RegisterTransitionState(OffStateInst);
	EmptyHopperStateInst->RegisterTransitionState(IdleStateInst);
	EmptyHopperStateInst->RegisterTransitionState(ClimbStateInst);
	ClimbStateInst->RegisterTransitionState(OffStateInst);
	ClimbStateInst->RegisterTransitionState(IdleStateInst);
	ClimbStateInst->RegisterTransitionState(PrepareToLaunchStateInst);
	LauncherTuningStateInst->RegisterTransitionState(OffStateInst);
	LauncherTuningStateInst->RegisterTransitionState(LaunchStateInst);
	ManualLaunchStateInst->RegisterTransitionState(OffStateInst);
	ManualLaunchStateInst->RegisterTransitionState(IdleStateInst);
}

Launcher::Launcher(RobotIdentifier activeRobotId) : BaseMech(MechanismTypes::MECHANISM_TYPE::LAUNCHER, std::string("Launcher")),
													m_activeRobotId(activeRobotId),
													m_stateMap(),
													m_chassis(ChassisConfigMgr::GetInstance()->GetSwerveChassis())
{
	PeriodicLooper::GetInstance()->RegisterAll(this);
	RobotState::GetInstance()->RegisterForStateChanges(this, RobotStateChanges::StateChange::AllowedToClimbStatus_Bool);
	RobotState::GetInstance()->RegisterForStateChanges(this, RobotStateChanges::StateChange::ClimbModeStatus_Bool);

	m_targetCalculator = RebuiltTargetCalculator::GetInstance();
}

std::map<std::string, Launcher::STATE_NAMES>
	Launcher::stringToSTATE_NAMESEnumMap{
		{"STATE_OFF", Launcher::STATE_NAMES::STATE_OFF},
		{"STATE_INITIALIZE", Launcher::STATE_NAMES::STATE_INITIALIZE},
		{"STATE_IDLE", Launcher::STATE_NAMES::STATE_IDLE},
		{"STATE_PREPARE_TO_LAUNCH", Launcher::STATE_NAMES::STATE_PREPARE_TO_LAUNCH},
		{"STATE_LAUNCH", Launcher::STATE_NAMES::STATE_LAUNCH},
		{"STATE_EMPTY_HOPPER", Launcher::STATE_NAMES::STATE_EMPTY_HOPPER},
		{"STATE_CLIMB", Launcher::STATE_NAMES::STATE_CLIMB},
		{"STATE_LAUNCHER_TUNING", Launcher::STATE_NAMES::STATE_LAUNCHER_TUNING},
		{"STATE_MANUAL_LAUNCH", Launcher::STATE_NAMES::STATE_MANUAL_LAUNCH}};

void Launcher::CreateBot(int launcherId, int hoodId, int transferId, int turretId, int indexerId, int agitatorId)
{
	m_ntName = "Launcher";
	ctre::phoenix6::CANBus canivore("canivore");
	m_launcher = new ctre::phoenix6::hardware::TalonFX(launcherId, canivore);
	m_hood = new ctre::phoenix6::hardware::TalonFXS(hoodId, canivore);
	m_transfer = new ctre::phoenix6::hardware::TalonFX(transferId, canivore);
	m_turret = new ctre::phoenix6::hardware::TalonFXS(turretId, canivore);
	m_indexer = new ctre::phoenix6::hardware::TalonFX(indexerId, canivore);
	m_agitator = new ctre::phoenix6::hardware::TalonFX(agitatorId, canivore);

	m_percentOut = CreateZeroControlData(ControlModes::CONTROL_TYPE::PERCENT_OUTPUT, "m_percentOut");
	m_velocityRPS = CreateZeroControlData(ControlModes::CONTROL_TYPE::VELOCITY_REV_PER_SEC, "m_velocityRPS");
	m_positionDegreesHood = CreateZeroControlData(ControlModes::CONTROL_TYPE::POSITION_DEGREES, "m_positionDegreesHood");
	m_positionDegreesTurret = CreateZeroControlData(ControlModes::CONTROL_TYPE::POSITION_DEGREES, "m_positionDegreesTurret");

	ReadConstants("Launcher.xml", 302);
}

void Launcher::InitializeBot()
{
	InitializeTalonFXLauncher();
	InitializeTalonFXSHood();
	InitializeTalonFXTransfer();
	InitializeTalonFXSTurret();
	InitializeTalonFXIndexer();
	InitializeTalonFXAgitator();
}

void Launcher::InitializeTalonFXLauncher()
{
	TalonFXConfiguration configs{};
	ApplyCurrentLimits(configs);
	ApplyVoltageConfig(configs);
	ApplyDisabledLimitSwitches(configs);
	ApplyDefaultMotorOutput(configs, InvertedValue::CounterClockwise_Positive, NeutralModeValue::Coast);
	ApplyDefaultFeedback(configs);
	ApplySlot0FromControlData(configs, m_velocityRPS);

	ApplyConfigWithRetry(m_launcher, configs, "m_launcher");
}

void Launcher::InitializeTalonFXSHood()
{
	TalonFXSConfiguration configs{};
	ApplyCurrentLimits(configs);
	ApplyVoltageConfig(configs);
	ApplyDefaultMotorOutput(configs, InvertedValue::CounterClockwise_Positive, NeutralModeValue::Brake);

	// Hood-specific limit switch configuration (remote CANdi sensors)
	configs.HardwareLimitSwitch.ForwardLimitEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 1;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::RemoteCANdiS1;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = true;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 1;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = true;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::RemoteCANdiS2;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	// TODO: Set Motion Magic params
	configs.MotionMagic.MotionMagicCruiseVelocity = units::angular_velocity::radians_per_second_t(0);
	configs.MotionMagic.MotionMagicAcceleration = units::angular_acceleration::radians_per_second_squared_t(0);
	configs.MotionMagic.MotionMagicJerk = units::angular_jerk::radians_per_second_cubed_t(0);
	configs.Commutation.MotorArrangement = MotorArrangementValue::Minion_JST;

	ApplySlot0FromControlData(configs, m_positionDegreesHood);

	ApplyConfigWithRetry(m_hood, configs, "m_hood");
}

void Launcher::InitializeTalonFXTransfer()
{
	TalonFXConfiguration configs{};
	ApplyCurrentLimits(configs);
	ApplyVoltageConfig(configs);
	ApplyDisabledLimitSwitches(configs);
	ApplyDefaultMotorOutput(configs, InvertedValue::Clockwise_Positive, NeutralModeValue::Coast);
	ApplyDefaultFeedback(configs);

	ApplyConfigWithRetry(m_transfer, configs, "m_transfer");
}

void Launcher::InitializeTalonFXSTurret()
{
	TalonFXSConfiguration configs{};
	ApplyCurrentLimits(configs);
	ApplyVoltageConfig(configs);
	ApplyDefaultMotorOutput(configs, InvertedValue::CounterClockwise_Positive, NeutralModeValue::Brake);

	// Turret-specific limit switch configuration (remote CANdi sensors)
	configs.HardwareLimitSwitch.ForwardLimitEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(270);
	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::RemoteCANdiS1;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = true;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = true;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(125);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::RemoteCANdiS2;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	// TODO: Set Motion Magic params
	configs.MotionMagic.MotionMagicCruiseVelocity = units::angular_velocity::radians_per_second_t(0);
	configs.MotionMagic.MotionMagicAcceleration = units::angular_acceleration::radians_per_second_squared_t(0);
	configs.MotionMagic.MotionMagicJerk = units::angular_jerk::radians_per_second_cubed_t(0);
	configs.Commutation.MotorArrangement = MotorArrangementValue::Minion_JST;

	ApplySlot0FromControlData(configs, m_positionDegreesTurret);

	ApplyConfigWithRetry(m_turret, configs, "m_turret");
}

void Launcher::InitializeTalonFXIndexer()
{
	TalonFXConfiguration configs{};
	ApplyCurrentLimits(configs);
	ApplyVoltageConfig(configs);
	ApplyDisabledLimitSwitches(configs);
	ApplyDefaultMotorOutput(configs, InvertedValue::CounterClockwise_Positive, NeutralModeValue::Coast);
	ApplyDefaultFeedback(configs);

	ApplyConfigWithRetry(m_indexer, configs, "m_indexer");
}

void Launcher::InitializeTalonFXAgitator()
{
	TalonFXConfiguration configs{};
	ApplyCurrentLimits(configs);
	ApplyVoltageConfig(configs);
	ApplyDisabledLimitSwitches(configs);
	ApplyDefaultMotorOutput(configs, InvertedValue::CounterClockwise_Positive, NeutralModeValue::Coast);
	ApplyDefaultFeedback(configs);

	ApplyConfigWithRetry(m_agitator, configs, "m_agitator");
}

void Launcher::SetCurrentState(int state, bool run)
{
	StateMgr::SetCurrentState(state, run);
}

void Launcher::RunCommonTasks()
{
	// This function is called once per loop before the current state Run()
	Cyclic();

	if (TeleopControl::GetInstance()->IsButtonPressed(TeleopControlFunctions::LAUNCHER_OFF))
	{
		if (m_launcherOffButtonReleased)
		{
			m_launcherProtectedMode = !m_launcherProtectedMode;
		}
		m_launcherOffButtonReleased = false;
	}
	else
	{
		m_launcherOffButtonReleased = true;
	}

	// Update Launcher Targets/Field
	m_targetCalculator->UpdateTargetOffset();
	CalculateTargets();
	UpdateLauncherTargets();

	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "Launcher", "Current State", GetCurrentState());
}

/// @brief  Set the control constants (e.g. PIDF values).
/// @param [in] ControlData*                                   pid:  the control constants
/// @return void
void Launcher::SetControlConstants(RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, int slot, ControlData pid)
{
}

/// @brief update the output to the mechanism using the current controller and target value(s)
/// @return void
void Launcher::Update()
{
	m_launcher->SetControl(*m_launcherActiveTarget);
	m_hood->SetControl(*m_hoodActiveTarget);
	m_transfer->SetControl(*m_transferActiveTarget);
	m_turret->SetControl(*m_turretActiveTarget);
	m_indexer->SetControl(*m_indexerActiveTarget);
}

void Launcher::Cyclic()
{
	Update();
}

ControlData *Launcher::GetControlData(string name)
{
	if (name.compare("PercentOut") == 0)
		return m_percentOut;
	if (name.compare("VelocityRPS") == 0)
		return m_velocityRPS;
	if (name.compare("PositionDegreesHood") == 0)
		return m_positionDegreesHood;
	if (name.compare("PositionDegreesTurret") == 0)
		return m_positionDegreesTurret;

	return nullptr;
}

void Launcher::PublishLaunchMode(bool launching)
{
	RobotState::GetInstance()->PublishStateChange(RobotStateChanges::StateChange::IsLaunching_Bool, launching);
}

void Launcher::NotifyStateUpdate(RobotStateChanges::StateChange statechange, bool value)
{
	if (statechange == RobotStateChanges::StateChange::ClimbModeStatus_Bool)
	{
		m_isClimbMode = value;
	}
	else if (statechange == RobotStateChanges::StateChange::AllowedToClimbStatus_Bool)
	{
		m_isAllowedToClimb = value;
	}
}

bool Launcher::IsLauncherAtTarget()
{
	// Launcher Speed error, Hood Angle error, Turret angle error are within a threshold, and if we are in launch zone. Also check chassis speed.
	units::angle::degree_t hoodError = m_hood->GetPosition().GetValue() - m_targetHoodAngle;
	units::angle::degree_t turretError = m_turret->GetPosition().GetValue() - m_targetTurretAngle;
	units::angular_velocity::revolutions_per_minute_t launcherSpeedError = m_launcher->GetVelocity().GetValue() - m_targetLauncherAngularVelocity;
	bool inLaunchzone = IsInLaunchZone();
	auto chassisSpeeds = m_chassis != nullptr ? m_chassis->GetState().Speeds : frc::ChassisSpeeds();

	auto Speed = units::math::sqrt(units::math::abs(chassisSpeeds.vx * chassisSpeeds.vx) + units::math::abs(chassisSpeeds.vy * chassisSpeeds.vy));

	return ((units::math::abs(hoodError) < m_hoodAngleThreshold) &&
			(units::math::abs(turretError) < m_turretAngleThreshold) &&
			(units::math::abs(launcherSpeedError) < m_launcherVelocityThreshold) &&
			(inLaunchzone) &&
			(Speed < m_chassisSpeedThreshold));
}

bool Launcher::IsInLaunchZone() const
{
	// call deadzone manager to see if we can or can't launch
	return true;
}

void Launcher::CalculateTargets()
{
	m_targetTurretAngle = m_targetCalculator->GetLauncherTarget(m_lookaheadTime, m_launcher->GetPosition().GetValue());
	units::length::inch_t distanceToTarget = m_targetCalculator->CalculateDistanceToTarget(m_lookaheadTime);

	// if (AllianceZoneManager::GetInstance()->IsInAllinaceZone())
	if (true)
	{
		m_targetHoodAngle = InterpolateUtils::linearInterpolate(m_scoringDistanceArray, m_scoringHoodAngleArray, distanceToTarget);
		m_targetLauncherAngularVelocity = InterpolateUtils::linearInterpolate(m_scoringDistanceArray, m_scoringLauncherVelocityArray, distanceToTarget);
	}
	else
	{
		m_targetHoodAngle = InterpolateUtils::linearInterpolate(m_passingDistanceArray, m_passingHoodAngleArray, units::length::foot_t(distanceToTarget));
		m_targetLauncherAngularVelocity = InterpolateUtils::linearInterpolate(m_passingDistanceArray, m_passingLauncherVelocityArray, units::length::foot_t(distanceToTarget));
	}

	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "Launcher", "Distance To Target", distanceToTarget.value());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "Launcher", "Hood Angle Target", m_targetHoodAngle.value());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "Launcher", "Launcher Speed Target", m_targetLauncherAngularVelocity.value());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "Launcher", "Launcher Speed RPM", units::angular_velocity::revolutions_per_minute_t(m_launcher->GetVelocity().GetValue()).value());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "Launcher", "Hood Angle", units::angle::degree_t(m_hood->GetPosition().GetValue()).value());
}

void Launcher::UpdateLauncherTargets()
{
	int currentState = GetCurrentState();

	if (currentState == STATE_NAMES::STATE_OFF ||
		currentState == STATE_NAMES::STATE_INITIALIZE ||
		currentState == STATE_NAMES::STATE_CLIMB ||
		currentState == STATE_NAMES::STATE_MANUAL_LAUNCH)
	{
		return;
	}

	UpdateTargetHoodPositionDegreesHood(m_targetHoodAngle);
	UpdateTargetTurretPositionDegreesTurret(m_targetTurretAngle);
	UpdateTargetLauncherVelocityRPS(m_targetLauncherAngularVelocity);
}