//====================================================================================================================================================
// Copyright 2026 Lake Orion Robotics FIRST Team 302
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
// OR OTHER DEALINGS IN THE SOFTWARE.
//====================================================================================================================================================
// This file was automatically generated by the Team 302 code generator version 20.26.00.00
// Generated on Thursday, January 22, 2026 11:43:04 PM

#include <string>

// FRC Includes
#include <networktables/NetworkTableInstance.h>
#include <frc/Timer.h>

#include "Launcher.h"
#include "utils/logging/debug/Logger.h"
#include "utils/PeriodicLooper.h"
#include "state/RobotState.h"
#include "utils/DragonPower.h"

#include "ctre/phoenix6/TalonFX.hpp"
#include "ctre/phoenix6/controls/Follower.hpp"
#include "ctre/phoenix6/configs/Configuration.hpp"
#include "ctre/phoenix6/TalonFXS.hpp"
#include "mechanisms/Launcher/OffState.h"
#include "mechanisms/Launcher/InitializeState.h"
#include "mechanisms/Launcher/IdleState.h"
#include "mechanisms/Launcher/PrepareToLaunchState.h"
#include "mechanisms/Launcher/LaunchState.h"
#include "mechanisms/Launcher/EmptyHopperState.h"
#include "mechanisms/Launcher/ClimbState.h"
#include "TeleopControl/TeleopControl.h"

using ctre::phoenix6::configs::Slot0Configs;
using ctre::phoenix6::configs::Slot1Configs;
using ctre::phoenix6::configs::TalonFXConfiguration;
using ctre::phoenix6::configs::TalonFXSConfiguration;
using ctre::phoenix6::signals::FeedbackSensorSourceValue;
using ctre::phoenix6::signals::ForwardLimitSourceValue;
using ctre::phoenix6::signals::ForwardLimitTypeValue;
using ctre::phoenix6::signals::GravityTypeValue;
using ctre::phoenix6::signals::InvertedValue;
using ctre::phoenix6::signals::MotorArrangementValue;
using ctre::phoenix6::signals::NeutralModeValue;
using ctre::phoenix6::signals::ReverseLimitSourceValue;
using ctre::phoenix6::signals::ReverseLimitTypeValue;
using ctre::phoenix6::signals::StaticFeedforwardSignValue;

using std::string;
using namespace LauncherStates;

void Launcher::CreateAndRegisterStates()
{
	OffState *OffStateInst = new OffState(string("Off"), 0, this, m_activeRobotId);
	AddToStateVector(OffStateInst);

	InitializeState *InitializeStateInst = new InitializeState(string("Initialize"), 1, this, m_activeRobotId);
	AddToStateVector(InitializeStateInst);

	IdleState *IdleStateInst = new IdleState(string("Idle"), 2, this, m_activeRobotId);
	AddToStateVector(IdleStateInst);

	PrepareToLaunchState *PrepareToLaunchStateInst = new PrepareToLaunchState(string("PrepareToLaunch"), 3, this, m_activeRobotId);
	AddToStateVector(PrepareToLaunchStateInst);

	LaunchState *LaunchStateInst = new LaunchState(string("Launch"), 4, this, m_activeRobotId);
	AddToStateVector(LaunchStateInst);

	EmptyHopperState *EmptyHopperStateInst = new EmptyHopperState(string("EmptyHopper"), 5, this, m_activeRobotId);
	AddToStateVector(EmptyHopperStateInst);

	ClimbState *ClimbStateInst = new ClimbState(string("Climb"), 6, this, m_activeRobotId);
	AddToStateVector(ClimbStateInst);

	OffStateInst->RegisterTransitionState(InitializeStateInst);
	InitializeStateInst->RegisterTransitionState(IdleStateInst);
	IdleStateInst->RegisterTransitionState(OffStateInst);
	IdleStateInst->RegisterTransitionState(PrepareToLaunchStateInst);
	IdleStateInst->RegisterTransitionState(EmptyHopperStateInst);
	IdleStateInst->RegisterTransitionState(ClimbStateInst);
	PrepareToLaunchStateInst->RegisterTransitionState(OffStateInst);
	PrepareToLaunchStateInst->RegisterTransitionState(IdleStateInst);
	PrepareToLaunchStateInst->RegisterTransitionState(LaunchStateInst);
	PrepareToLaunchStateInst->RegisterTransitionState(EmptyHopperStateInst);
	PrepareToLaunchStateInst->RegisterTransitionState(ClimbStateInst);
	LaunchStateInst->RegisterTransitionState(OffStateInst);
	LaunchStateInst->RegisterTransitionState(IdleStateInst);
	LaunchStateInst->RegisterTransitionState(PrepareToLaunchStateInst);
	EmptyHopperStateInst->RegisterTransitionState(OffStateInst);
	EmptyHopperStateInst->RegisterTransitionState(IdleStateInst);
	EmptyHopperStateInst->RegisterTransitionState(ClimbStateInst);
	ClimbStateInst->RegisterTransitionState(OffStateInst);
	ClimbStateInst->RegisterTransitionState(IdleStateInst);
}

Launcher::Launcher(RobotIdentifier activeRobotId) : BaseMech(MechanismTypes::MECHANISM_TYPE::LAUNCHER, std::string("Launcher")),
													m_activeRobotId(activeRobotId),
													m_stateMap()
{
	PeriodicLooper::GetInstance()->RegisterAll(this);
	RobotState::GetInstance()->RegisterForStateChanges(this, RobotStateChanges::StateChange::AllowedToClimbStatus_Bool);
	RobotState::GetInstance()->RegisterForStateChanges(this, RobotStateChanges::StateChange::ClimbModeStatus_Bool);

	// InitializeLogging();
}

/* void Launcher::InitializeLogging()
 {
	wpi::log::DataLog &log = frc::DataLogManager::GetLog();

	 m_LauncherTotalEnergyLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Launcher/TotalEnergy");
m_LauncherTotalEnergyLogEntry.Append(0.0);
m_LauncherTotalWattHoursLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Launcher/TotalWattHours");
m_LauncherTotalWattHoursLogEntry.Append(0.0);
m_LauncherLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Launcher/LauncherPosition");
m_LauncherLogEntry.Append(0.0);
m_launcherTargetLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Launcher/LauncherTarget");
m_launcherTargetLogEntry.Append(0.0);
m_LauncherPowerLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Launcher/LauncherPower");
m_LauncherPowerLogEntry.Append(0.0);
m_LauncherEnergyLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Launcher/LauncherEnergy");
m_LauncherEnergyLogEntry.Append(0.0);
m_HoodLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Launcher/HoodPosition");
m_HoodLogEntry.Append(0.0);
m_hoodTargetLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Launcher/HoodTarget");
m_hoodTargetLogEntry.Append(0.0);
m_HoodPowerLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Launcher/HoodPower");
m_HoodPowerLogEntry.Append(0.0);
m_HoodEnergyLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Launcher/HoodEnergy");
m_HoodEnergyLogEntry.Append(0.0);
m_TransferLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Launcher/TransferPosition");
m_TransferLogEntry.Append(0.0);
m_transferTargetLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Launcher/TransferTarget");
m_transferTargetLogEntry.Append(0.0);
m_TransferPowerLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Launcher/TransferPower");
m_TransferPowerLogEntry.Append(0.0);
m_TransferEnergyLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Launcher/TransferEnergy");
m_TransferEnergyLogEntry.Append(0.0);
m_TurretLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Launcher/TurretPosition");
m_TurretLogEntry.Append(0.0);
m_turretTargetLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Launcher/TurretTarget");
m_turretTargetLogEntry.Append(0.0);
m_TurretPowerLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Launcher/TurretPower");
m_TurretPowerLogEntry.Append(0.0);
m_TurretEnergyLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Launcher/TurretEnergy");
m_TurretEnergyLogEntry.Append(0.0);
m_IndexerLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Launcher/IndexerPosition");
m_IndexerLogEntry.Append(0.0);
m_indexerTargetLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Launcher/IndexerTarget");
m_indexerTargetLogEntry.Append(0.0);
m_IndexerPowerLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Launcher/IndexerPower");
m_IndexerPowerLogEntry.Append(0.0);
m_IndexerEnergyLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Launcher/IndexerEnergy");
m_IndexerEnergyLogEntry.Append(0.0);
m_LauncherStateLogEntry = wpi::log::IntegerLogEntry(log, "mechanisms/Launcher/State");
m_LauncherStateLogEntry.Append(0);
 }*/

std::map<std::string, Launcher::STATE_NAMES>
	Launcher::stringToSTATE_NAMESEnumMap{
		{"STATE_OFF", Launcher::STATE_NAMES::STATE_OFF},
		{"STATE_INITIALIZE", Launcher::STATE_NAMES::STATE_INITIALIZE},
		{"STATE_IDLE", Launcher::STATE_NAMES::STATE_IDLE},
		{"STATE_PREPARE_TO_LAUNCH", Launcher::STATE_NAMES::STATE_PREPARE_TO_LAUNCH},
		{"STATE_LAUNCH", Launcher::STATE_NAMES::STATE_LAUNCH},
		{"STATE_EMPTY_HOPPER", Launcher::STATE_NAMES::STATE_EMPTY_HOPPER},
		{"STATE_CLIMB", Launcher::STATE_NAMES::STATE_CLIMB},
	};

void Launcher::CreateCompBot302()
{
	m_ntName = "Launcher";
	m_launcher = new ctre::phoenix6::hardware::TalonFX(16, ctre::phoenix6::CANBus("canivore"));
	m_hood = new ctre::phoenix6::hardware::TalonFXS(17, ctre::phoenix6::CANBus("canivore"));
	m_transfer = new ctre::phoenix6::hardware::TalonFX(18, ctre::phoenix6::CANBus("canivore"));
	m_turret = new ctre::phoenix6::hardware::TalonFXS(19, ctre::phoenix6::CANBus("canivore"));
	m_indexer = new ctre::phoenix6::hardware::TalonFX(20, ctre::phoenix6::CANBus("canivore"));

	m_percentOut = new ControlData(
		ControlModes::CONTROL_TYPE::PERCENT_OUTPUT,		  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_percentOut",									  // std::string indentifier
		0,												  // double proportional
		0,												  // double integral
		0,												  // double derivative
		0,												  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::DUTY_CYCLE,				 // FEEDFORWARD_TYPE feedforwadType
		0,														 // double integralZone
		0,														 // double maxAcceleration
		0,														 // double cruiseVelocity
		0,														 // double peakValue
		0,														 // double nominalValue
		false,													 // bool enableFOC
		ControlData::GravityTypeValue::Elevator_Static,			 // Gravity type
		ControlData::StaticFeedforwardSignValue::UseVelocitySign // Static feedforward sign
	);
	m_velocityRPS = new ControlData(
		ControlModes::CONTROL_TYPE::VELOCITY_REV_PER_SEC, // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_velocityRPS",								  // std::string indentifier
		0,												  // double proportional
		0,												  // double integral
		0,												  // double derivative
		0,												  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::DUTY_CYCLE,				 // FEEDFORWARD_TYPE feedforwadType
		0,														 // double integralZone
		0,														 // double maxAcceleration
		0,														 // double cruiseVelocity
		0,														 // double peakValue
		0,														 // double nominalValue
		false,													 // bool enableFOC
		ControlData::GravityTypeValue::Elevator_Static,			 // Gravity type
		ControlData::StaticFeedforwardSignValue::UseVelocitySign // Static feedforward sign
	);
	m_positionDegreesHood = new ControlData(
		ControlModes::CONTROL_TYPE::POSITION_DEGREES,	  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_positionDegreesHood",						  // std::string indentifier
		0,												  // double proportional
		0,												  // double integral
		0,												  // double derivative
		0,												  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::DUTY_CYCLE,				 // FEEDFORWARD_TYPE feedforwadType
		0,														 // double integralZone
		0,														 // double maxAcceleration
		0,														 // double cruiseVelocity
		0,														 // double peakValue
		0,														 // double nominalValue
		false,													 // bool enableFOC
		ControlData::GravityTypeValue::Elevator_Static,			 // Gravity type
		ControlData::StaticFeedforwardSignValue::UseVelocitySign // Static feedforward sign
	);
	m_positionDegreesTurret = new ControlData(
		ControlModes::CONTROL_TYPE::POSITION_DEGREES,	  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_positionDegreesTurret",						  // std::string indentifier
		0,												  // double proportional
		0,												  // double integral
		0,												  // double derivative
		0,												  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::DUTY_CYCLE,				 // FEEDFORWARD_TYPE feedforwadType
		0,														 // double integralZone
		0,														 // double maxAcceleration
		0,														 // double cruiseVelocity
		0,														 // double peakValue
		0,														 // double nominalValue
		false,													 // bool enableFOC
		ControlData::GravityTypeValue::Elevator_Static,			 // Gravity type
		ControlData::StaticFeedforwardSignValue::UseVelocitySign // Static feedforward sign
	);

	ReadConstants("Launcher.xml", 302);
}

void Launcher::InitializeCompBot302()
{
	InitializeTalonFXLauncherCompBot302();
	InitializeTalonFXSHoodCompBot302();
	InitializeTalonFXTransferCompBot302();
	InitializeTalonFXSTurretCompBot302();
	InitializeTalonFXIndexerCompBot302();
}
void Launcher::InitializeTalonFXLauncherCompBot302()
{
	TalonFXConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(100);
	configs.CurrentLimits.StatorCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(70);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(35);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.ClosedLoopRamps.TorqueClosedLoopRampPeriod = units::time::second_t(0.25);

	configs.HardwareLimitSwitch.ForwardLimitEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::CounterClockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Coast;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue::RotorSensor;
	configs.Feedback.SensorToMechanismRatio = 1;

	configs.Slot0.kI = m_velocityRPS->GetI();
	configs.Slot0.kD = m_velocityRPS->GetD();
	configs.Slot0.kG = m_velocityRPS->GetF();
	configs.Slot0.kS = m_velocityRPS->GetS();
	configs.Slot0.kV = m_velocityRPS->GetV();
	configs.Slot0.kP = m_velocityRPS->GetP();
	configs.Slot0.kA = m_velocityRPS->GetA();
	configs.Slot0.GravityType = m_velocityRPS->GetGravityType();
	configs.Slot0.StaticFeedforwardSign = m_velocityRPS->GetStaticFeedforwardSign();

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_launcher->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_launcher", "m_launcher Status", status.GetName());
}

void Launcher::InitializeTalonFXSHoodCompBot302()
{
	TalonFXSConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(100);
	configs.CurrentLimits.StatorCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(70);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(35);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.ClosedLoopRamps.TorqueClosedLoopRampPeriod = units::time::second_t(0.25);

	// MECH_TODO: Set limit switches
	configs.HardwareLimitSwitch.ForwardLimitEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::RemoteCANdiS1;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = true;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::RemoteCANdiS2;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::CounterClockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	// MECH_TODO: Set Motion Magic params
	configs.MotionMagic.MotionMagicCruiseVelocity = units::angular_velocity::radians_per_second_t(0);
	configs.MotionMagic.MotionMagicAcceleration = units::angular_acceleration::radians_per_second_squared_t(0);
	configs.MotionMagic.MotionMagicJerk = units::angular_jerk::radians_per_second_cubed_t(0);
	configs.Commutation.MotorArrangement = MotorArrangementValue::Disabled;

	configs.Slot0.kI = m_positionDegreesHood->GetI();
	configs.Slot0.kD = m_positionDegreesHood->GetD();
	configs.Slot0.kG = m_positionDegreesHood->GetF();
	configs.Slot0.kS = m_positionDegreesHood->GetS();
	configs.Slot0.kV = m_positionDegreesHood->GetV();
	configs.Slot0.kP = m_positionDegreesHood->GetP();
	configs.Slot0.kA = m_positionDegreesHood->GetA();
	configs.Slot0.GravityType = m_positionDegreesHood->GetGravityType();
	configs.Slot0.StaticFeedforwardSign = m_positionDegreesHood->GetStaticFeedforwardSign();

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_hood->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_hood", "m_hood Status", status.GetName());
}

void Launcher::InitializeTalonFXTransferCompBot302()
{
	TalonFXConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(100);
	configs.CurrentLimits.StatorCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(70);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(35);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.ClosedLoopRamps.TorqueClosedLoopRampPeriod = units::time::second_t(0.25);

	configs.HardwareLimitSwitch.ForwardLimitEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::CounterClockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Coast;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue::RotorSensor;
	configs.Feedback.SensorToMechanismRatio = 1;

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_transfer->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_transfer", "m_transfer Status", status.GetName());
}

void Launcher::InitializeTalonFXSTurretCompBot302()
{
	TalonFXSConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(100);
	configs.CurrentLimits.StatorCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(70);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(35);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.ClosedLoopRamps.TorqueClosedLoopRampPeriod = units::time::second_t(0.25);

	// MECH_TODO: Set limit switches
	configs.HardwareLimitSwitch.ForwardLimitEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 1;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(180);
	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = true;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 1;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = true;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::CounterClockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	// MECH_TODO: Set Motion Magic params
	configs.MotionMagic.MotionMagicCruiseVelocity = units::angular_velocity::radians_per_second_t(0);
	configs.MotionMagic.MotionMagicAcceleration = units::angular_acceleration::radians_per_second_squared_t(0);
	configs.MotionMagic.MotionMagicJerk = units::angular_jerk::radians_per_second_cubed_t(0);
	configs.Commutation.MotorArrangement = MotorArrangementValue::Disabled;

	configs.Slot0.kI = m_positionDegreesTurret->GetI();
	configs.Slot0.kD = m_positionDegreesTurret->GetD();
	configs.Slot0.kG = m_positionDegreesTurret->GetF();
	configs.Slot0.kS = m_positionDegreesTurret->GetS();
	configs.Slot0.kV = m_positionDegreesTurret->GetV();
	configs.Slot0.kP = m_positionDegreesTurret->GetP();
	configs.Slot0.kA = m_positionDegreesTurret->GetA();
	configs.Slot0.GravityType = m_positionDegreesTurret->GetGravityType();
	configs.Slot0.StaticFeedforwardSign = m_positionDegreesTurret->GetStaticFeedforwardSign();

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_turret->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_turret", "m_turret Status", status.GetName());
}

void Launcher::InitializeTalonFXIndexerCompBot302()
{
	TalonFXConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(100);
	configs.CurrentLimits.StatorCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(70);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(35);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.ClosedLoopRamps.TorqueClosedLoopRampPeriod = units::time::second_t(0.25);

	configs.HardwareLimitSwitch.ForwardLimitEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::CounterClockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Coast;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue::RotorSensor;
	configs.Feedback.SensorToMechanismRatio = 1;

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_indexer->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_indexer", "m_indexer Status", status.GetName());
}

void Launcher::SetCurrentState(int state, bool run)
{
	StateMgr::SetCurrentState(state, run);
}

void Launcher::RunCommonTasks()
{
	// This function is called once per loop before the current state Run()
	Cyclic();
	if (TeleopControl::GetInstance()->IsButtonPressed(TeleopControlFunctions::LAUNCHER_OFF))
	{
		m_launcherProtect = !m_launcherProtect;
	}
}

/// @brief  Set the control constants (e.g. PIDF values).
/// @param [in] ControlData*                                   pid:  the control constants
/// @return void
void Launcher::SetControlConstants(RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, int slot, ControlData pid)
{
}

/// @brief update the output to the mechanism using the current controller and target value(s)
/// @return void
void Launcher::Update()
{
	m_launcher->SetControl(*m_launcherActiveTarget);
	m_hood->SetControl(*m_hoodActiveTarget);
	m_transfer->SetControl(*m_transferActiveTarget);
	m_turret->SetControl(*m_turretActiveTarget);
	m_indexer->SetControl(*m_indexerActiveTarget);
}

void Launcher::Cyclic()
{
	Update();
}

ControlData *Launcher::GetControlData(string name)
{
	if (name.compare("PercentOut") == 0)
		return m_percentOut;
	if (name.compare("VelocityRPS") == 0)
		return m_velocityRPS;
	if (name.compare("PositionDegreesHood") == 0)
		return m_positionDegreesHood;
	if (name.compare("PositionDegreesTurret") == 0)
		return m_positionDegreesTurret;

	return nullptr;
}

void Launcher::PublishLaunchMode(bool launching)
{
	RobotState::GetInstance()->PublishStateChange(RobotStateChanges::StateChange::IsLaunching_Bool, launching);
}

void Launcher::NotifyStateUpdate(RobotStateChanges::StateChange statechange, bool value)
{
	if (statechange == RobotStateChanges::StateChange::ClimbModeStatus_Bool)
	{
		m_isClimbMode = value;
	}
	else if (statechange == RobotStateChanges::StateChange::AllowedToClimbStatus_Bool)
	{
		m_isAllowedToClimb = value;
	}
}

/* void Launcher::DataLog(uint64_t timestamp)
{
   auto currTime = m_powerTimer.Get();
LogLauncher(timestamp, m_Launcher->GetPosition().GetValueAsDouble());
auto LauncherPower = DragonPower::CalcPowerEnergy(currTime, m_Launcher->GetSupplyVoltage().GetValueAsDouble(), m_Launcher->GetSupplyCurrent().GetValueAsDouble());
m_power = get<0>(LauncherPower);
m_energy = get<1>(LauncherPower);
m_totalEnergy += m_energy;
LogLauncherPower(timestamp, m_power);
LogLauncherEnergy(timestamp, m_energy);
LogHood(timestamp, m_Hood->GetPosition().GetValueAsDouble());
auto HoodPower = DragonPower::CalcPowerEnergy(currTime, m_Hood->GetSupplyVoltage().GetValueAsDouble(), m_Hood->GetSupplyCurrent().GetValueAsDouble());
m_power = get<0>(HoodPower);
m_energy = get<1>(HoodPower);
m_totalEnergy += m_energy;
LogHoodPower(timestamp, m_power);
LogHoodEnergy(timestamp, m_energy);
LogTransfer(timestamp, m_Transfer->GetPosition().GetValueAsDouble());
auto TransferPower = DragonPower::CalcPowerEnergy(currTime, m_Transfer->GetSupplyVoltage().GetValueAsDouble(), m_Transfer->GetSupplyCurrent().GetValueAsDouble());
m_power = get<0>(TransferPower);
m_energy = get<1>(TransferPower);
m_totalEnergy += m_energy;
LogTransferPower(timestamp, m_power);
LogTransferEnergy(timestamp, m_energy);
LogTurret(timestamp, m_Turret->GetPosition().GetValueAsDouble());
auto TurretPower = DragonPower::CalcPowerEnergy(currTime, m_Turret->GetSupplyVoltage().GetValueAsDouble(), m_Turret->GetSupplyCurrent().GetValueAsDouble());
m_power = get<0>(TurretPower);
m_energy = get<1>(TurretPower);
m_totalEnergy += m_energy;
LogTurretPower(timestamp, m_power);
LogTurretEnergy(timestamp, m_energy);
LogIndexer(timestamp, m_Indexer->GetPosition().GetValueAsDouble());
auto IndexerPower = DragonPower::CalcPowerEnergy(currTime, m_Indexer->GetSupplyVoltage().GetValueAsDouble(), m_Indexer->GetSupplyCurrent().GetValueAsDouble());
m_power = get<0>(IndexerPower);
m_energy = get<1>(IndexerPower);
m_totalEnergy += m_energy;
LogIndexerPower(timestamp, m_power);
LogIndexerEnergy(timestamp, m_energy);
LogLauncherState(timestamp, GetCurrentState());
m_totalWattHours += DragonPower::ConvertEnergyToWattHours(m_totalEnergy);
LogLauncherTotalEnergy(timestamp, m_totalEnergy);
LogLauncherTotalWattHours(timestamp, m_totalWattHours);
m_powerTimer.Reset();
m_powerTimer.Start();
 }*/