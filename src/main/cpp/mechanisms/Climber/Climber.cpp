//====================================================================================================================================================
// Copyright 2026 Lake Orion Robotics FIRST Team 302
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
// OR OTHER DEALINGS IN THE SOFTWARE.
//====================================================================================================================================================
// This file was automatically generated by the Team 302 code generator version 20.26.00.00
// Generated on Friday, January 23, 2026 12:20:12 PM

#include <string>

// FRC Includes
#include <networktables/NetworkTableInstance.h>
#include <frc/Timer.h>

#include "Climber.h"
#include "utils/logging/debug/Logger.h"
#include "utils/PeriodicLooper.h"
#include "state/RobotState.h"
#include "utils/DragonPower.h"

#include "ctre/phoenix6/TalonFX.hpp"
#include "ctre/phoenix6/controls/Follower.hpp"
#include "ctre/phoenix6/configs/Configuration.hpp"
#include "frc/Solenoid.h"
#include <ctre/phoenix6/CANcoder.hpp>
#include <ctre/phoenix6/configs/Configurator.hpp>
#include <ctre/phoenix6/signals/SpnEnums.hpp>
#include "mechanisms/Climber/OffState.h"
#include "mechanisms/Climber/WantToClimbState.h"
#include "mechanisms/Climber/PrepareToClimbState.h"
#include "mechanisms/Climber/L1ClimbState.h"
#include "mechanisms/Climber/L3ClimbState.h"
#include "mechanisms/Climber/ExitState.h"
#include "mechanisms/Climber/AutonL1ClimbState.h"
#include "teleopcontrol/TeleopControlFunctions.h"
#include "teleopcontrol/TeleopControl.h"

using ctre::phoenix6::configs::Slot0Configs;
using ctre::phoenix6::configs::Slot1Configs;
using ctre::phoenix6::configs::TalonFXConfiguration;
using ctre::phoenix6::signals::FeedbackSensorSourceValue;
using ctre::phoenix6::signals::ForwardLimitSourceValue;
using ctre::phoenix6::signals::ForwardLimitTypeValue;
using ctre::phoenix6::signals::GravityTypeValue;
using ctre::phoenix6::signals::InvertedValue;
using ctre::phoenix6::signals::NeutralModeValue;
using ctre::phoenix6::signals::ReverseLimitSourceValue;
using ctre::phoenix6::signals::ReverseLimitTypeValue;
using ctre::phoenix6::signals::StaticFeedforwardSignValue;

using std::string;
using namespace ClimberStates;

void Climber::CreateAndRegisterStates()
{
	OffState *OffStateInst = new OffState(string("Off"), 0, this, m_activeRobotId);
	AddToStateVector(OffStateInst);

	WantToClimbState *WantToClimbStateInst = new WantToClimbState(string("WantToClimb"), 1, this, m_activeRobotId);
	AddToStateVector(WantToClimbStateInst);

	PrepareToClimbState *PrepareToClimbStateInst = new PrepareToClimbState(string("PrepareToClimb"), 2, this, m_activeRobotId);
	AddToStateVector(PrepareToClimbStateInst);

	L1ClimbState *L1ClimbStateInst = new L1ClimbState(string("L1Climb"), 3, this, m_activeRobotId);
	AddToStateVector(L1ClimbStateInst);

	L3ClimbState *L3ClimbStateInst = new L3ClimbState(string("L3Climb"), 4, this, m_activeRobotId);
	AddToStateVector(L3ClimbStateInst);

	ExitState *ExitStateInst = new ExitState(string("Exit"), 5, this, m_activeRobotId);
	AddToStateVector(ExitStateInst);

	AutonL1ClimbState *AutonL1ClimbStateInst = new AutonL1ClimbState(string("AutonL1Climb"), 6, this, m_activeRobotId);
	AddToStateVector(AutonL1ClimbStateInst);

	OffStateInst->RegisterTransitionState(WantToClimbStateInst);
	WantToClimbStateInst->RegisterTransitionState(OffStateInst);
	WantToClimbStateInst->RegisterTransitionState(PrepareToClimbStateInst);
	PrepareToClimbStateInst->RegisterTransitionState(OffStateInst);
	PrepareToClimbStateInst->RegisterTransitionState(L1ClimbStateInst);
	PrepareToClimbStateInst->RegisterTransitionState(L3ClimbStateInst);
	L1ClimbStateInst->RegisterTransitionState(L3ClimbStateInst);
	L1ClimbStateInst->RegisterTransitionState(ExitStateInst);
	L3ClimbStateInst->RegisterTransitionState(L1ClimbStateInst);
	L3ClimbStateInst->RegisterTransitionState(ExitStateInst);
	ExitStateInst->RegisterTransitionState(OffStateInst);
	AutonL1ClimbStateInst->RegisterTransitionState(ExitStateInst);
}

Climber::Climber(RobotIdentifier activeRobotId) : BaseMech(MechanismTypes::MECHANISM_TYPE::CLIMBER, std::string("Climber")),
												  m_activeRobotId(activeRobotId),
												  m_stateMap(),
												  m_climbModeStatus(false),
												  m_allowedToClimb(false),
												  m_chassis(ChassisConfigMgr::GetInstance()->GetSwerveChassis())
{
	PeriodicLooper::GetInstance()->RegisterAll(this);
	RobotState::GetInstance()->RegisterForStateChanges(this, RobotStateChanges::StateChange::ClimbModeStatus_Bool);
	RobotState::GetInstance()->RegisterForStateChanges(this, RobotStateChanges::StateChange::AllowedToClimbStatus_Bool);

	// InitializeLogging();
}

/* void Climber::InitializeLogging()
 {
	wpi::log::DataLog &log = frc::DataLogManager::GetLog();

	 m_ClimberTotalEnergyLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Climber/TotalEnergy");
m_ClimberTotalEnergyLogEntry.Append(0.0);
m_ClimberTotalWattHoursLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Climber/TotalWattHours");
m_ClimberTotalWattHoursLogEntry.Append(0.0);
m_ClimberLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Climber/ClimberPosition");
m_ClimberLogEntry.Append(0.0);
m_climberTargetLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Climber/ClimberTarget");
m_climberTargetLogEntry.Append(0.0);
m_ClimberPowerLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Climber/ClimberPower");
m_ClimberPowerLogEntry.Append(0.0);
m_ClimberEnergyLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Climber/ClimberEnergy");
m_ClimberEnergyLogEntry.Append(0.0);
m_ClimberStateLogEntry = wpi::log::IntegerLogEntry(log, "mechanisms/Climber/State");
m_ClimberStateLogEntry.Append(0);
 }*/

std::map<std::string, Climber::STATE_NAMES>
	Climber::stringToSTATE_NAMESEnumMap{
		{"STATE_OFF", Climber::STATE_NAMES::STATE_OFF},
		{"STATE_WANT_TO_CLIMB", Climber::STATE_NAMES::STATE_WANT_TO_CLIMB},
		{"STATE_PREPARE_TO_CLIMB", Climber::STATE_NAMES::STATE_PREPARE_TO_CLIMB},
		{"STATE_L1CLIMB", Climber::STATE_NAMES::STATE_L1CLIMB},
		{"STATE_L3CLIMB", Climber::STATE_NAMES::STATE_L3CLIMB},
		{"STATE_EXIT", Climber::STATE_NAMES::STATE_EXIT},
		{"STATE_AUTON_L1CLIMB", Climber::STATE_NAMES::STATE_AUTON_L1CLIMB}};

void Climber::CreateCompBot302()
{
	m_ntName = "Climber";
	m_climber = new ctre::phoenix6::hardware::TalonFX(12, ctre::phoenix6::CANBus("canivore"));

	m_extender = new frc::Solenoid(1, frc::PneumaticsModuleType::REVPH, 2);
	m_alignment = new frc::Solenoid(1, frc::PneumaticsModuleType::REVPH, 3);

	ctre::phoenix6::configs::CANcoderConfiguration ClimberRotationConfigs{};
	ClimberRotationConfigs.MagnetSensor.MagnetOffset = units::angle::turn_t(0);
	ClimberRotationConfigs.MagnetSensor.SensorDirection = ctre::phoenix6::signals::SensorDirectionValue::CounterClockwise_Positive;
	m_climberRotation = new ctre::phoenix6::hardware::CANcoder(12, ctre::phoenix6::CANBus("canivore"));
	m_climberRotation->GetConfigurator().Apply(ClimberRotationConfigs);

	m_positionDegree = new ControlData(
		ControlModes::CONTROL_TYPE::POSITION_DEGREES,	  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_positionDegree",								  // std::string indentifier
		0,												  // double proportional
		0,												  // double integral
		0,												  // double derivative
		0,												  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::DUTY_CYCLE,				 // FEEDFORWARD_TYPE feedforwadType
		0,														 // double integralZone
		0,														 // double maxAcceleration
		0,														 // double cruiseVelocity
		0,														 // double peakValue
		0,														 // double nominalValue
		false,													 // bool enableFOC
		ControlData::GravityTypeValue::Arm_Cosine,				 // Gravity type
		ControlData::StaticFeedforwardSignValue::UseVelocitySign // Static feedforward sign
	);

	ReadConstants("Climber.xml", 302);
}

void Climber::InitializeCompBot302()
{
	InitializeTalonFXClimberCompBot302();
}
void Climber::InitializeTalonFXClimberCompBot302()
{
	TalonFXConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(100);
	configs.CurrentLimits.StatorCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(70);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(35);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.ClosedLoopRamps.TorqueClosedLoopRampPeriod = units::time::second_t(0.25);

	configs.HardwareLimitSwitch.ForwardLimitEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::CounterClockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.Feedback.FeedbackRemoteSensorID = 12; // MECH_TODO: Verify CAN ID
	configs.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue::FusedCANcoder;
	configs.Feedback.SensorToMechanismRatio = 0;
	configs.Feedback.RotorToSensorRatio = 0;

	/*MECH_TODO: Define Motion Magic Params

	configs.MotionMagic.MotionMagicCruiseVelocity = units::angular_velocity::turns_per_second_t(850);
	configs.MotionMagic.MotionMagicAcceleration = units::angular_acceleration::turns_per_second_squared_t(1000);
	configs.MotionMagic.MotionMagicJerk = units::angular_jerk::radians_per_second_cubed_t(0);
	configs.MotionMagic.MotionMagicExpo_kV = ctre::unit::volts_per_turn_per_second_t(0.05);
	configs.MotionMagic.MotionMagicExpo_kA = ctre::unit::volts_per_turn_per_second_squared_t(0.08);]
	*/
	configs.Slot0.kI = m_positionDegree->GetI();
	configs.Slot0.kD = m_positionDegree->GetD();
	configs.Slot0.kG = m_positionDegree->GetF();
	configs.Slot0.kS = m_positionDegree->GetS();
	configs.Slot0.kV = m_positionDegree->GetV();
	configs.Slot0.kP = m_positionDegree->GetP();
	configs.Slot0.kA = m_positionDegree->GetA();
	configs.Slot0.GravityType = m_positionDegree->GetGravityType();
	configs.Slot0.StaticFeedforwardSign = m_positionDegree->GetStaticFeedforwardSign();

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_climber->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_climber", "m_climber Status", status.GetName());
}

void Climber::SetCurrentState(int state, bool run)
{
	StateMgr::SetCurrentState(state, run);
}

void Climber::RunCommonTasks()
{
	// This function is called once per loop before the current state Run()
	Cyclic();
}

/// @brief  Set the control constants (e.g. PIDF values).
/// @param [in] ControlData*                                   pid:  the control constants
/// @return void
void Climber::SetControlConstants(RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, int slot, ControlData pid)
{
}

/// @brief update the output to the mechanism using the current controller and target value(s)
/// @return void
void Climber::Update()
{
	m_climber->SetControl(*m_climberActiveTarget);
}

void Climber::Cyclic()
{
	Update();
}
void Climber::NotifyStateUpdate(RobotStateChanges::StateChange statechange, bool value)
{
	if (statechange == RobotStateChanges::StateChange::ClimbModeStatus_Bool)
	{
		m_climbModeStatus = value;
	}

	else if (statechange == RobotStateChanges::StateChange::AllowedToClimbStatus_Bool)
	{
		m_allowedToClimb = value;
	}
}

ControlData *Climber::GetControlData(string name)
{
	if (name.compare("PositionDegree") == 0)
		return m_positionDegree;

	return nullptr;
}
void Climber::ManualClimb(units::angle::degree_t climbTarget)
{
	auto climberPosition = GetClimber()->GetPosition().GetValue();
	double manualClimberPercent = TeleopControl::GetInstance()->GetAxisValue(TeleopControlFunctions::CLIMB_MANUAL_ROTATE_UP) - TeleopControl::GetInstance()->GetAxisValue(TeleopControlFunctions::CLIMB_MANUAL_ROTATE_DOWN);

	if (climberPosition < climbTarget) // so we keep climbing if we are up
		UpdateTargetClimberPercentOut(m_holdPercentOut);

	if (abs(manualClimberPercent) > 0.075)
	{
		double climberPercentOutTarget = manualClimberPercent * m_percentOutScale;
		UpdateTargetClimberPercentOut(climberPercentOutTarget);
	}
	else
	{
		UpdateTargetClimberPercentOut(0.0);
	}
}
units::angle::degree_t Climber::GetPigeonPitch()
{
	units::angle::degree_t pigeonPitch = m_chassis->GetPigeon2().GetPitch().GetValue();
	return pigeonPitch;
}
/* void Climber::DataLog(uint64_t timestamp)
{
   auto currTime = m_powerTimer.Get();
LogClimber(timestamp, m_Climber->GetPosition().GetValueAsDouble());
auto ClimberPower = DragonPower::CalcPowerEnergy(currTime, m_Climber->GetSupplyVoltage().GetValueAsDouble(), m_Climber->GetSupplyCurrent().GetValueAsDouble());
m_power = get<0>(ClimberPower);
m_energy = get<1>(ClimberPower);
m_totalEnergy += m_energy;
LogClimberPower(timestamp, m_power);
LogClimberEnergy(timestamp, m_energy);
LogClimberState(timestamp, GetCurrentState());
m_totalWattHours += DragonPower::ConvertEnergyToWattHours(m_totalEnergy);
LogClimberTotalEnergy(timestamp, m_totalEnergy);
LogClimberTotalWattHours(timestamp, m_totalWattHours);
m_powerTimer.Reset();
m_powerTimer.Start();
 }*/