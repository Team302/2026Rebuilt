// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: commands.proto
#ifdef __FRC_ROBORIO__

#ifndef GOOGLE_PROTOBUF_INCLUDED_commands_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_commands_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "geometry3d.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_commands_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal
{
  class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_commands_2eproto
{
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_commands_2eproto;
namespace questnav
{
  namespace protos
  {
    namespace commands
    {
      class ProtobufQuestNavCommand;
      struct ProtobufQuestNavCommandDefaultTypeInternal;
      extern ProtobufQuestNavCommandDefaultTypeInternal _ProtobufQuestNavCommand_default_instance_;
      class ProtobufQuestNavCommandResponse;
      struct ProtobufQuestNavCommandResponseDefaultTypeInternal;
      extern ProtobufQuestNavCommandResponseDefaultTypeInternal _ProtobufQuestNavCommandResponse_default_instance_;
      class ProtobufQuestNavPoseResetPayload;
      struct ProtobufQuestNavPoseResetPayloadDefaultTypeInternal;
      extern ProtobufQuestNavPoseResetPayloadDefaultTypeInternal _ProtobufQuestNavPoseResetPayload_default_instance_;
    } // namespace commands
  } // namespace protos
} // namespace questnav
PROTOBUF_NAMESPACE_OPEN
template <>
::questnav::protos::commands::ProtobufQuestNavCommand *Arena::CreateMaybeMessage<::questnav::protos::commands::ProtobufQuestNavCommand>(Arena *);
template <>
::questnav::protos::commands::ProtobufQuestNavCommandResponse *Arena::CreateMaybeMessage<::questnav::protos::commands::ProtobufQuestNavCommandResponse>(Arena *);
template <>
::questnav::protos::commands::ProtobufQuestNavPoseResetPayload *Arena::CreateMaybeMessage<::questnav::protos::commands::ProtobufQuestNavPoseResetPayload>(Arena *);
PROTOBUF_NAMESPACE_CLOSE
namespace questnav
{
  namespace protos
  {
    namespace commands
    {

      enum QuestNavCommandType : int
      {
        COMMAND_TYPE_UNSPECIFIED = 0,
        POSE_RESET = 1,
        QuestNavCommandType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
        QuestNavCommandType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
      };
      bool QuestNavCommandType_IsValid(int value);
      constexpr QuestNavCommandType QuestNavCommandType_MIN = COMMAND_TYPE_UNSPECIFIED;
      constexpr QuestNavCommandType QuestNavCommandType_MAX = POSE_RESET;
      constexpr int QuestNavCommandType_ARRAYSIZE = QuestNavCommandType_MAX + 1;

      const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor *QuestNavCommandType_descriptor();
      template <typename T>
      inline const std::string &QuestNavCommandType_Name(T enum_t_value)
      {
        static_assert(::std::is_same<T, QuestNavCommandType>::value ||
                          ::std::is_integral<T>::value,
                      "Incorrect type passed to function QuestNavCommandType_Name.");
        return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
            QuestNavCommandType_descriptor(), enum_t_value);
      }
      inline bool QuestNavCommandType_Parse(
          ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, QuestNavCommandType *value)
      {
        return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QuestNavCommandType>(
            QuestNavCommandType_descriptor(), name, value);
      }
      // ===================================================================

      class ProtobufQuestNavPoseResetPayload final : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:questnav.protos.commands.ProtobufQuestNavPoseResetPayload) */
      {
      public:
        inline ProtobufQuestNavPoseResetPayload() : ProtobufQuestNavPoseResetPayload(nullptr) {}
        ~ProtobufQuestNavPoseResetPayload() override;
        explicit PROTOBUF_CONSTEXPR ProtobufQuestNavPoseResetPayload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

        ProtobufQuestNavPoseResetPayload(const ProtobufQuestNavPoseResetPayload &from);
        ProtobufQuestNavPoseResetPayload(ProtobufQuestNavPoseResetPayload &&from) noexcept
            : ProtobufQuestNavPoseResetPayload()
        {
          *this = ::std::move(from);
        }

        inline ProtobufQuestNavPoseResetPayload &operator=(const ProtobufQuestNavPoseResetPayload &from)
        {
          CopyFrom(from);
          return *this;
        }
        inline ProtobufQuestNavPoseResetPayload &operator=(ProtobufQuestNavPoseResetPayload &&from) noexcept
        {
          if (this == &from)
            return *this;
          if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
              && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
          )
          {
            InternalSwap(&from);
          }
          else
          {
            CopyFrom(from);
          }
          return *this;
        }

        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
        {
          return GetDescriptor();
        }
        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
        {
          return default_instance().GetMetadata().descriptor;
        }
        static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
        {
          return default_instance().GetMetadata().reflection;
        }
        static const ProtobufQuestNavPoseResetPayload &default_instance()
        {
          return *internal_default_instance();
        }
        static inline const ProtobufQuestNavPoseResetPayload *internal_default_instance()
        {
          return reinterpret_cast<const ProtobufQuestNavPoseResetPayload *>(
              &_ProtobufQuestNavPoseResetPayload_default_instance_);
        }
        static constexpr int kIndexInFileMessages =
            0;

        friend void swap(ProtobufQuestNavPoseResetPayload &a, ProtobufQuestNavPoseResetPayload &b)
        {
          a.Swap(&b);
        }
        inline void Swap(ProtobufQuestNavPoseResetPayload *other)
        {
          if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
          if (GetOwningArena() != nullptr &&
              GetOwningArena() == other->GetOwningArena())
          {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
          if (GetOwningArena() == other->GetOwningArena())
          {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
          }
          else
          {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
          }
        }
        void UnsafeArenaSwap(ProtobufQuestNavPoseResetPayload *other)
        {
          if (other == this)
            return;
          GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
          InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        ProtobufQuestNavPoseResetPayload *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
        {
          return CreateMaybeMessage<ProtobufQuestNavPoseResetPayload>(arena);
        }
        using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
        void CopyFrom(const ProtobufQuestNavPoseResetPayload &from);
        using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
        void MergeFrom(const ProtobufQuestNavPoseResetPayload &from)
        {
          ProtobufQuestNavPoseResetPayload::MergeImpl(*this, from);
        }

      private:
        static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message &to_msg, const ::PROTOBUF_NAMESPACE_ID::Message &from_msg);

      public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool IsInitialized() const final;

        size_t ByteSizeLong() const final;
        const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
        uint8_t *_InternalSerialize(
            uint8_t *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;
        int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

      private:
        void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned);
        void SharedDtor();
        void SetCachedSize(int size) const final;
        void InternalSwap(ProtobufQuestNavPoseResetPayload *other);

      private:
        friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
        static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
        {
          return "questnav.protos.commands.ProtobufQuestNavPoseResetPayload";
        }

      protected:
        explicit ProtobufQuestNavPoseResetPayload(::PROTOBUF_NAMESPACE_ID::Arena *arena,
                                                  bool is_message_owned = false);

      public:
        static const ClassData _class_data_;
        const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

        ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        enum : int
        {
          kTargetPoseFieldNumber = 1,
        };
        // .wpi.proto.ProtobufPose3d target_pose = 1;
        bool has_target_pose() const;

      private:
        bool _internal_has_target_pose() const;

      public:
        void clear_target_pose();
        const ::wpi::proto::ProtobufPose3d &target_pose() const;
        PROTOBUF_NODISCARD ::wpi::proto::ProtobufPose3d *release_target_pose();
        ::wpi::proto::ProtobufPose3d *mutable_target_pose();
        void set_allocated_target_pose(::wpi::proto::ProtobufPose3d *target_pose);

      private:
        const ::wpi::proto::ProtobufPose3d &_internal_target_pose() const;
        ::wpi::proto::ProtobufPose3d *_internal_mutable_target_pose();

      public:
        void unsafe_arena_set_allocated_target_pose(
            ::wpi::proto::ProtobufPose3d *target_pose);
        ::wpi::proto::ProtobufPose3d *unsafe_arena_release_target_pose();

        // @@protoc_insertion_point(class_scope:questnav.protos.commands.ProtobufQuestNavPoseResetPayload)
      private:
        class _Internal;

        template <typename T>
        friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
        typedef void InternalArenaConstructable_;
        typedef void DestructorSkippable_;
        struct Impl_
        {
          ::wpi::proto::ProtobufPose3d *target_pose_;
          mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        };
        union
        {
          Impl_ _impl_;
        };
        friend struct ::TableStruct_commands_2eproto;
      };
      // -------------------------------------------------------------------

      class ProtobufQuestNavCommand final : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:questnav.protos.commands.ProtobufQuestNavCommand) */
      {
      public:
        inline ProtobufQuestNavCommand() : ProtobufQuestNavCommand(nullptr) {}
        ~ProtobufQuestNavCommand() override;
        explicit PROTOBUF_CONSTEXPR ProtobufQuestNavCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

        ProtobufQuestNavCommand(const ProtobufQuestNavCommand &from);
        ProtobufQuestNavCommand(ProtobufQuestNavCommand &&from) noexcept
            : ProtobufQuestNavCommand()
        {
          *this = ::std::move(from);
        }

        inline ProtobufQuestNavCommand &operator=(const ProtobufQuestNavCommand &from)
        {
          CopyFrom(from);
          return *this;
        }
        inline ProtobufQuestNavCommand &operator=(ProtobufQuestNavCommand &&from) noexcept
        {
          if (this == &from)
            return *this;
          if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
              && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
          )
          {
            InternalSwap(&from);
          }
          else
          {
            CopyFrom(from);
          }
          return *this;
        }

        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
        {
          return GetDescriptor();
        }
        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
        {
          return default_instance().GetMetadata().descriptor;
        }
        static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
        {
          return default_instance().GetMetadata().reflection;
        }
        static const ProtobufQuestNavCommand &default_instance()
        {
          return *internal_default_instance();
        }
        enum PayloadCase
        {
          kPoseResetPayload = 10,
          PAYLOAD_NOT_SET = 0,
        };

        static inline const ProtobufQuestNavCommand *internal_default_instance()
        {
          return reinterpret_cast<const ProtobufQuestNavCommand *>(
              &_ProtobufQuestNavCommand_default_instance_);
        }
        static constexpr int kIndexInFileMessages =
            1;

        friend void swap(ProtobufQuestNavCommand &a, ProtobufQuestNavCommand &b)
        {
          a.Swap(&b);
        }
        inline void Swap(ProtobufQuestNavCommand *other)
        {
          if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
          if (GetOwningArena() != nullptr &&
              GetOwningArena() == other->GetOwningArena())
          {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
          if (GetOwningArena() == other->GetOwningArena())
          {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
          }
          else
          {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
          }
        }
        void UnsafeArenaSwap(ProtobufQuestNavCommand *other)
        {
          if (other == this)
            return;
          GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
          InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        ProtobufQuestNavCommand *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
        {
          return CreateMaybeMessage<ProtobufQuestNavCommand>(arena);
        }
        using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
        void CopyFrom(const ProtobufQuestNavCommand &from);
        using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
        void MergeFrom(const ProtobufQuestNavCommand &from)
        {
          ProtobufQuestNavCommand::MergeImpl(*this, from);
        }

      private:
        static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message &to_msg, const ::PROTOBUF_NAMESPACE_ID::Message &from_msg);

      public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool IsInitialized() const final;

        size_t ByteSizeLong() const final;
        const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
        uint8_t *_InternalSerialize(
            uint8_t *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;
        int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

      private:
        void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned);
        void SharedDtor();
        void SetCachedSize(int size) const final;
        void InternalSwap(ProtobufQuestNavCommand *other);

      private:
        friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
        static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
        {
          return "questnav.protos.commands.ProtobufQuestNavCommand";
        }

      protected:
        explicit ProtobufQuestNavCommand(::PROTOBUF_NAMESPACE_ID::Arena *arena,
                                         bool is_message_owned = false);

      public:
        static const ClassData _class_data_;
        const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

        ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        enum : int
        {
          kTypeFieldNumber = 1,
          kCommandIdFieldNumber = 2,
          kPoseResetPayloadFieldNumber = 10,
        };
        // .questnav.protos.commands.QuestNavCommandType type = 1;
        void clear_type();
        ::questnav::protos::commands::QuestNavCommandType type() const;
        void set_type(::questnav::protos::commands::QuestNavCommandType value);

      private:
        ::questnav::protos::commands::QuestNavCommandType _internal_type() const;
        void _internal_set_type(::questnav::protos::commands::QuestNavCommandType value);

      public:
        // uint32 command_id = 2;
        void clear_command_id();
        uint32_t command_id() const;
        void set_command_id(uint32_t value);

      private:
        uint32_t _internal_command_id() const;
        void _internal_set_command_id(uint32_t value);

      public:
        // .questnav.protos.commands.ProtobufQuestNavPoseResetPayload pose_reset_payload = 10;
        bool has_pose_reset_payload() const;

      private:
        bool _internal_has_pose_reset_payload() const;

      public:
        void clear_pose_reset_payload();
        const ::questnav::protos::commands::ProtobufQuestNavPoseResetPayload &pose_reset_payload() const;
        PROTOBUF_NODISCARD ::questnav::protos::commands::ProtobufQuestNavPoseResetPayload *release_pose_reset_payload();
        ::questnav::protos::commands::ProtobufQuestNavPoseResetPayload *mutable_pose_reset_payload();
        void set_allocated_pose_reset_payload(::questnav::protos::commands::ProtobufQuestNavPoseResetPayload *pose_reset_payload);

      private:
        const ::questnav::protos::commands::ProtobufQuestNavPoseResetPayload &_internal_pose_reset_payload() const;
        ::questnav::protos::commands::ProtobufQuestNavPoseResetPayload *_internal_mutable_pose_reset_payload();

      public:
        void unsafe_arena_set_allocated_pose_reset_payload(
            ::questnav::protos::commands::ProtobufQuestNavPoseResetPayload *pose_reset_payload);
        ::questnav::protos::commands::ProtobufQuestNavPoseResetPayload *unsafe_arena_release_pose_reset_payload();

        void clear_payload();
        PayloadCase payload_case() const;
        // @@protoc_insertion_point(class_scope:questnav.protos.commands.ProtobufQuestNavCommand)
      private:
        class _Internal;
        void set_has_pose_reset_payload();

        inline bool has_payload() const;
        inline void clear_has_payload();

        template <typename T>
        friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
        typedef void InternalArenaConstructable_;
        typedef void DestructorSkippable_;
        struct Impl_
        {
          int type_;
          uint32_t command_id_;
          union PayloadUnion
          {
            constexpr PayloadUnion() : _constinit_{} {}
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            ::questnav::protos::commands::ProtobufQuestNavPoseResetPayload *pose_reset_payload_;
          } payload_;
          mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
          uint32_t _oneof_case_[1];
        };
        union
        {
          Impl_ _impl_;
        };
        friend struct ::TableStruct_commands_2eproto;
      };
      // -------------------------------------------------------------------

      class ProtobufQuestNavCommandResponse final : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:questnav.protos.commands.ProtobufQuestNavCommandResponse) */
      {
      public:
        inline ProtobufQuestNavCommandResponse() : ProtobufQuestNavCommandResponse(nullptr) {}
        ~ProtobufQuestNavCommandResponse() override;
        explicit PROTOBUF_CONSTEXPR ProtobufQuestNavCommandResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

        ProtobufQuestNavCommandResponse(const ProtobufQuestNavCommandResponse &from);
        ProtobufQuestNavCommandResponse(ProtobufQuestNavCommandResponse &&from) noexcept
            : ProtobufQuestNavCommandResponse()
        {
          *this = ::std::move(from);
        }

        inline ProtobufQuestNavCommandResponse &operator=(const ProtobufQuestNavCommandResponse &from)
        {
          CopyFrom(from);
          return *this;
        }
        inline ProtobufQuestNavCommandResponse &operator=(ProtobufQuestNavCommandResponse &&from) noexcept
        {
          if (this == &from)
            return *this;
          if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
              && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
          )
          {
            InternalSwap(&from);
          }
          else
          {
            CopyFrom(from);
          }
          return *this;
        }

        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
        {
          return GetDescriptor();
        }
        static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
        {
          return default_instance().GetMetadata().descriptor;
        }
        static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
        {
          return default_instance().GetMetadata().reflection;
        }
        static const ProtobufQuestNavCommandResponse &default_instance()
        {
          return *internal_default_instance();
        }
        static inline const ProtobufQuestNavCommandResponse *internal_default_instance()
        {
          return reinterpret_cast<const ProtobufQuestNavCommandResponse *>(
              &_ProtobufQuestNavCommandResponse_default_instance_);
        }
        static constexpr int kIndexInFileMessages =
            2;

        friend void swap(ProtobufQuestNavCommandResponse &a, ProtobufQuestNavCommandResponse &b)
        {
          a.Swap(&b);
        }
        inline void Swap(ProtobufQuestNavCommandResponse *other)
        {
          if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
          if (GetOwningArena() != nullptr &&
              GetOwningArena() == other->GetOwningArena())
          {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
          if (GetOwningArena() == other->GetOwningArena())
          {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
          }
          else
          {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
          }
        }
        void UnsafeArenaSwap(ProtobufQuestNavCommandResponse *other)
        {
          if (other == this)
            return;
          GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
          InternalSwap(other);
        }

        // implements Message ----------------------------------------------

        ProtobufQuestNavCommandResponse *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
        {
          return CreateMaybeMessage<ProtobufQuestNavCommandResponse>(arena);
        }
        using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
        void CopyFrom(const ProtobufQuestNavCommandResponse &from);
        using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
        void MergeFrom(const ProtobufQuestNavCommandResponse &from)
        {
          ProtobufQuestNavCommandResponse::MergeImpl(*this, from);
        }

      private:
        static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message &to_msg, const ::PROTOBUF_NAMESPACE_ID::Message &from_msg);

      public:
        PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
        bool IsInitialized() const final;

        size_t ByteSizeLong() const final;
        const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
        uint8_t *_InternalSerialize(
            uint8_t *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;
        int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

      private:
        void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned);
        void SharedDtor();
        void SetCachedSize(int size) const final;
        void InternalSwap(ProtobufQuestNavCommandResponse *other);

      private:
        friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
        static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
        {
          return "questnav.protos.commands.ProtobufQuestNavCommandResponse";
        }

      protected:
        explicit ProtobufQuestNavCommandResponse(::PROTOBUF_NAMESPACE_ID::Arena *arena,
                                                 bool is_message_owned = false);

      public:
        static const ClassData _class_data_;
        const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

        ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        // nested types ----------------------------------------------------

        // accessors -------------------------------------------------------

        enum : int
        {
          kErrorMessageFieldNumber = 3,
          kCommandIdFieldNumber = 1,
          kSuccessFieldNumber = 2,
        };
        // string error_message = 3;
        void clear_error_message();
        const std::string &error_message() const;
        template <typename ArgT0 = const std::string &, typename... ArgT>
        void set_error_message(ArgT0 &&arg0, ArgT... args);
        std::string *mutable_error_message();
        PROTOBUF_NODISCARD std::string *release_error_message();
        void set_allocated_error_message(std::string *error_message);

      private:
        const std::string &_internal_error_message() const;
        inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string &value);
        std::string *_internal_mutable_error_message();

      public:
        // uint32 command_id = 1;
        void clear_command_id();
        uint32_t command_id() const;
        void set_command_id(uint32_t value);

      private:
        uint32_t _internal_command_id() const;
        void _internal_set_command_id(uint32_t value);

      public:
        // bool success = 2;
        void clear_success();
        bool success() const;
        void set_success(bool value);

      private:
        bool _internal_success() const;
        void _internal_set_success(bool value);

      public:
        // @@protoc_insertion_point(class_scope:questnav.protos.commands.ProtobufQuestNavCommandResponse)
      private:
        class _Internal;

        template <typename T>
        friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
        typedef void InternalArenaConstructable_;
        typedef void DestructorSkippable_;
        struct Impl_
        {
          ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
          uint32_t command_id_;
          bool success_;
          mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        };
        union
        {
          Impl_ _impl_;
        };
        friend struct ::TableStruct_commands_2eproto;
      };
      // ===================================================================

      // ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
      // ProtobufQuestNavPoseResetPayload

      // .wpi.proto.ProtobufPose3d target_pose = 1;
      inline bool ProtobufQuestNavPoseResetPayload::_internal_has_target_pose() const
      {
        return this != internal_default_instance() && _impl_.target_pose_ != nullptr;
      }
      inline bool ProtobufQuestNavPoseResetPayload::has_target_pose() const
      {
        return _internal_has_target_pose();
      }
      inline const ::wpi::proto::ProtobufPose3d &ProtobufQuestNavPoseResetPayload::_internal_target_pose() const
      {
        const ::wpi::proto::ProtobufPose3d *p = _impl_.target_pose_;
        return p != nullptr ? *p : reinterpret_cast<const ::wpi::proto::ProtobufPose3d &>(::wpi::proto::_ProtobufPose3d_default_instance_);
      }
      inline const ::wpi::proto::ProtobufPose3d &ProtobufQuestNavPoseResetPayload::target_pose() const
      {
        // @@protoc_insertion_point(field_get:questnav.protos.commands.ProtobufQuestNavPoseResetPayload.target_pose)
        return _internal_target_pose();
      }
      inline void ProtobufQuestNavPoseResetPayload::unsafe_arena_set_allocated_target_pose(
          ::wpi::proto::ProtobufPose3d *target_pose)
      {
        if (GetArenaForAllocation() == nullptr)
        {
          delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(_impl_.target_pose_);
        }
        _impl_.target_pose_ = target_pose;
        if (target_pose)
        {
        }
        else
        {
        }
        // @@protoc_insertion_point(field_unsafe_arena_set_allocated:questnav.protos.commands.ProtobufQuestNavPoseResetPayload.target_pose)
      }
      inline ::wpi::proto::ProtobufPose3d *ProtobufQuestNavPoseResetPayload::release_target_pose()
      {

        ::wpi::proto::ProtobufPose3d *temp = _impl_.target_pose_;
        _impl_.target_pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
        auto *old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(temp);
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        if (GetArenaForAllocation() == nullptr)
        {
          delete old;
        }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
        if (GetArenaForAllocation() != nullptr)
        {
          temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
        return temp;
      }
      inline ::wpi::proto::ProtobufPose3d *ProtobufQuestNavPoseResetPayload::unsafe_arena_release_target_pose()
      {
        // @@protoc_insertion_point(field_release:questnav.protos.commands.ProtobufQuestNavPoseResetPayload.target_pose)

        ::wpi::proto::ProtobufPose3d *temp = _impl_.target_pose_;
        _impl_.target_pose_ = nullptr;
        return temp;
      }
      inline ::wpi::proto::ProtobufPose3d *ProtobufQuestNavPoseResetPayload::_internal_mutable_target_pose()
      {

        if (_impl_.target_pose_ == nullptr)
        {
          auto *p = CreateMaybeMessage<::wpi::proto::ProtobufPose3d>(GetArenaForAllocation());
          _impl_.target_pose_ = p;
        }
        return _impl_.target_pose_;
      }
      inline ::wpi::proto::ProtobufPose3d *ProtobufQuestNavPoseResetPayload::mutable_target_pose()
      {
        ::wpi::proto::ProtobufPose3d *_msg = _internal_mutable_target_pose();
        // @@protoc_insertion_point(field_mutable:questnav.protos.commands.ProtobufQuestNavPoseResetPayload.target_pose)
        return _msg;
      }
      inline void ProtobufQuestNavPoseResetPayload::set_allocated_target_pose(::wpi::proto::ProtobufPose3d *target_pose)
      {
        ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArenaForAllocation();
        if (message_arena == nullptr)
        {
          delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(_impl_.target_pose_);
        }
        if (target_pose)
        {
          ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena =
              ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(target_pose));
          if (message_arena != submessage_arena)
          {
            target_pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
                message_arena, target_pose, submessage_arena);
          }
        }
        else
        {
        }
        _impl_.target_pose_ = target_pose;
        // @@protoc_insertion_point(field_set_allocated:questnav.protos.commands.ProtobufQuestNavPoseResetPayload.target_pose)
      }

      // -------------------------------------------------------------------

      // ProtobufQuestNavCommand

      // .questnav.protos.commands.QuestNavCommandType type = 1;
      inline void ProtobufQuestNavCommand::clear_type()
      {
        _impl_.type_ = 0;
      }
      inline ::questnav::protos::commands::QuestNavCommandType ProtobufQuestNavCommand::_internal_type() const
      {
        return static_cast<::questnav::protos::commands::QuestNavCommandType>(_impl_.type_);
      }
      inline ::questnav::protos::commands::QuestNavCommandType ProtobufQuestNavCommand::type() const
      {
        // @@protoc_insertion_point(field_get:questnav.protos.commands.ProtobufQuestNavCommand.type)
        return _internal_type();
      }
      inline void ProtobufQuestNavCommand::_internal_set_type(::questnav::protos::commands::QuestNavCommandType value)
      {

        _impl_.type_ = value;
      }
      inline void ProtobufQuestNavCommand::set_type(::questnav::protos::commands::QuestNavCommandType value)
      {
        _internal_set_type(value);
        // @@protoc_insertion_point(field_set:questnav.protos.commands.ProtobufQuestNavCommand.type)
      }

      // uint32 command_id = 2;
      inline void ProtobufQuestNavCommand::clear_command_id()
      {
        _impl_.command_id_ = 0u;
      }
      inline uint32_t ProtobufQuestNavCommand::_internal_command_id() const
      {
        return _impl_.command_id_;
      }
      inline uint32_t ProtobufQuestNavCommand::command_id() const
      {
        // @@protoc_insertion_point(field_get:questnav.protos.commands.ProtobufQuestNavCommand.command_id)
        return _internal_command_id();
      }
      inline void ProtobufQuestNavCommand::_internal_set_command_id(uint32_t value)
      {

        _impl_.command_id_ = value;
      }
      inline void ProtobufQuestNavCommand::set_command_id(uint32_t value)
      {
        _internal_set_command_id(value);
        // @@protoc_insertion_point(field_set:questnav.protos.commands.ProtobufQuestNavCommand.command_id)
      }

      // .questnav.protos.commands.ProtobufQuestNavPoseResetPayload pose_reset_payload = 10;
      inline bool ProtobufQuestNavCommand::_internal_has_pose_reset_payload() const
      {
        return payload_case() == kPoseResetPayload;
      }
      inline bool ProtobufQuestNavCommand::has_pose_reset_payload() const
      {
        return _internal_has_pose_reset_payload();
      }
      inline void ProtobufQuestNavCommand::set_has_pose_reset_payload()
      {
        _impl_._oneof_case_[0] = kPoseResetPayload;
      }
      inline void ProtobufQuestNavCommand::clear_pose_reset_payload()
      {
        if (_internal_has_pose_reset_payload())
        {
          if (GetArenaForAllocation() == nullptr)
          {
            delete _impl_.payload_.pose_reset_payload_;
          }
          clear_has_payload();
        }
      }
      inline ::questnav::protos::commands::ProtobufQuestNavPoseResetPayload *ProtobufQuestNavCommand::release_pose_reset_payload()
      {
        // @@protoc_insertion_point(field_release:questnav.protos.commands.ProtobufQuestNavCommand.pose_reset_payload)
        if (_internal_has_pose_reset_payload())
        {
          clear_has_payload();
          ::questnav::protos::commands::ProtobufQuestNavPoseResetPayload *temp = _impl_.payload_.pose_reset_payload_;
          if (GetArenaForAllocation() != nullptr)
          {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
          }
          _impl_.payload_.pose_reset_payload_ = nullptr;
          return temp;
        }
        else
        {
          return nullptr;
        }
      }
      inline const ::questnav::protos::commands::ProtobufQuestNavPoseResetPayload &ProtobufQuestNavCommand::_internal_pose_reset_payload() const
      {
        return _internal_has_pose_reset_payload()
                   ? *_impl_.payload_.pose_reset_payload_
                   : reinterpret_cast<::questnav::protos::commands::ProtobufQuestNavPoseResetPayload &>(::questnav::protos::commands::_ProtobufQuestNavPoseResetPayload_default_instance_);
      }
      inline const ::questnav::protos::commands::ProtobufQuestNavPoseResetPayload &ProtobufQuestNavCommand::pose_reset_payload() const
      {
        // @@protoc_insertion_point(field_get:questnav.protos.commands.ProtobufQuestNavCommand.pose_reset_payload)
        return _internal_pose_reset_payload();
      }
      inline ::questnav::protos::commands::ProtobufQuestNavPoseResetPayload *ProtobufQuestNavCommand::unsafe_arena_release_pose_reset_payload()
      {
        // @@protoc_insertion_point(field_unsafe_arena_release:questnav.protos.commands.ProtobufQuestNavCommand.pose_reset_payload)
        if (_internal_has_pose_reset_payload())
        {
          clear_has_payload();
          ::questnav::protos::commands::ProtobufQuestNavPoseResetPayload *temp = _impl_.payload_.pose_reset_payload_;
          _impl_.payload_.pose_reset_payload_ = nullptr;
          return temp;
        }
        else
        {
          return nullptr;
        }
      }
      inline void ProtobufQuestNavCommand::unsafe_arena_set_allocated_pose_reset_payload(::questnav::protos::commands::ProtobufQuestNavPoseResetPayload *pose_reset_payload)
      {
        clear_payload();
        if (pose_reset_payload)
        {
          set_has_pose_reset_payload();
          _impl_.payload_.pose_reset_payload_ = pose_reset_payload;
        }
        // @@protoc_insertion_point(field_unsafe_arena_set_allocated:questnav.protos.commands.ProtobufQuestNavCommand.pose_reset_payload)
      }
      inline ::questnav::protos::commands::ProtobufQuestNavPoseResetPayload *ProtobufQuestNavCommand::_internal_mutable_pose_reset_payload()
      {
        if (!_internal_has_pose_reset_payload())
        {
          clear_payload();
          set_has_pose_reset_payload();
          _impl_.payload_.pose_reset_payload_ = CreateMaybeMessage<::questnav::protos::commands::ProtobufQuestNavPoseResetPayload>(GetArenaForAllocation());
        }
        return _impl_.payload_.pose_reset_payload_;
      }
      inline ::questnav::protos::commands::ProtobufQuestNavPoseResetPayload *ProtobufQuestNavCommand::mutable_pose_reset_payload()
      {
        ::questnav::protos::commands::ProtobufQuestNavPoseResetPayload *_msg = _internal_mutable_pose_reset_payload();
        // @@protoc_insertion_point(field_mutable:questnav.protos.commands.ProtobufQuestNavCommand.pose_reset_payload)
        return _msg;
      }

      inline bool ProtobufQuestNavCommand::has_payload() const
      {
        return payload_case() != PAYLOAD_NOT_SET;
      }
      inline void ProtobufQuestNavCommand::clear_has_payload()
      {
        _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
      }
      inline ProtobufQuestNavCommand::PayloadCase ProtobufQuestNavCommand::payload_case() const
      {
        return ProtobufQuestNavCommand::PayloadCase(_impl_._oneof_case_[0]);
      }
      // -------------------------------------------------------------------

      // ProtobufQuestNavCommandResponse

      // uint32 command_id = 1;
      inline void ProtobufQuestNavCommandResponse::clear_command_id()
      {
        _impl_.command_id_ = 0u;
      }
      inline uint32_t ProtobufQuestNavCommandResponse::_internal_command_id() const
      {
        return _impl_.command_id_;
      }
      inline uint32_t ProtobufQuestNavCommandResponse::command_id() const
      {
        // @@protoc_insertion_point(field_get:questnav.protos.commands.ProtobufQuestNavCommandResponse.command_id)
        return _internal_command_id();
      }
      inline void ProtobufQuestNavCommandResponse::_internal_set_command_id(uint32_t value)
      {

        _impl_.command_id_ = value;
      }
      inline void ProtobufQuestNavCommandResponse::set_command_id(uint32_t value)
      {
        _internal_set_command_id(value);
        // @@protoc_insertion_point(field_set:questnav.protos.commands.ProtobufQuestNavCommandResponse.command_id)
      }

      // bool success = 2;
      inline void ProtobufQuestNavCommandResponse::clear_success()
      {
        _impl_.success_ = false;
      }
      inline bool ProtobufQuestNavCommandResponse::_internal_success() const
      {
        return _impl_.success_;
      }
      inline bool ProtobufQuestNavCommandResponse::success() const
      {
        // @@protoc_insertion_point(field_get:questnav.protos.commands.ProtobufQuestNavCommandResponse.success)
        return _internal_success();
      }
      inline void ProtobufQuestNavCommandResponse::_internal_set_success(bool value)
      {

        _impl_.success_ = value;
      }
      inline void ProtobufQuestNavCommandResponse::set_success(bool value)
      {
        _internal_set_success(value);
        // @@protoc_insertion_point(field_set:questnav.protos.commands.ProtobufQuestNavCommandResponse.success)
      }

      // string error_message = 3;
      inline void ProtobufQuestNavCommandResponse::clear_error_message()
      {
        _impl_.error_message_.ClearToEmpty();
      }
      inline const std::string &ProtobufQuestNavCommandResponse::error_message() const
      {
        // @@protoc_insertion_point(field_get:questnav.protos.commands.ProtobufQuestNavCommandResponse.error_message)
        return _internal_error_message();
      }
      template <typename ArgT0, typename... ArgT>
      inline PROTOBUF_ALWAYS_INLINE void ProtobufQuestNavCommandResponse::set_error_message(ArgT0 &&arg0, ArgT... args)
      {

        _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
        // @@protoc_insertion_point(field_set:questnav.protos.commands.ProtobufQuestNavCommandResponse.error_message)
      }
      inline std::string *ProtobufQuestNavCommandResponse::mutable_error_message()
      {
        std::string *_s = _internal_mutable_error_message();
        // @@protoc_insertion_point(field_mutable:questnav.protos.commands.ProtobufQuestNavCommandResponse.error_message)
        return _s;
      }
      inline const std::string &ProtobufQuestNavCommandResponse::_internal_error_message() const
      {
        return _impl_.error_message_.Get();
      }
      inline void ProtobufQuestNavCommandResponse::_internal_set_error_message(const std::string &value)
      {

        _impl_.error_message_.Set(value, GetArenaForAllocation());
      }
      inline std::string *ProtobufQuestNavCommandResponse::_internal_mutable_error_message()
      {

        return _impl_.error_message_.Mutable(GetArenaForAllocation());
      }
      inline std::string *ProtobufQuestNavCommandResponse::release_error_message()
      {
        // @@protoc_insertion_point(field_release:questnav.protos.commands.ProtobufQuestNavCommandResponse.error_message)
        return _impl_.error_message_.Release();
      }
      inline void ProtobufQuestNavCommandResponse::set_allocated_error_message(std::string *error_message)
      {
        if (error_message != nullptr)
        {
        }
        else
        {
        }
        _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_message_.IsDefault())
        {
          _impl_.error_message_.Set("", GetArenaForAllocation());
        }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
        // @@protoc_insertion_point(field_set_allocated:questnav.protos.commands.ProtobufQuestNavCommandResponse.error_message)
      }

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
      // -------------------------------------------------------------------

      // -------------------------------------------------------------------

      // @@protoc_insertion_point(namespace_scope)

    } // namespace commands
  } // namespace protos
} // namespace questnav

PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::questnav::protos::commands::QuestNavCommandType> : ::std::true_type
{
};
template <>
inline const EnumDescriptor *GetEnumDescriptor<::questnav::protos::commands::QuestNavCommandType>()
{
  return ::questnav::protos::commands::QuestNavCommandType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_commands_2eproto
#endif // __FRC_ROBORIO__