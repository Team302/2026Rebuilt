//====================================================================================================================================================
// TARGET CALCULATOR USAGE GUIDE
//====================================================================================================================================================
// 
// The TargetCalculator system provides a flexible framework for calculating distances and angles
// to scoring targets from the chassis position. It's designed to:
//
// 1. Calculate target distances and angles in robot frame (relative to robot orientation)
// 2. Compute virtual targets that compensate for robot movement during projectile flight
// 3. Support multiple target locations through dynamic zone selection
// 4. Account for launcher/mechanism offsets from robot center
//
//====================================================================================================================================================
// ARCHITECTURE OVERVIEW
//====================================================================================================================================================
//
// TargetCalculator (Base Class)
// ├── Core Math Functions
// │   ├── CalculateDistanceToTarget()
// │   ├── CalculateAngleToTarget()
// │   ├── CalculateLauncherDistanceToTarget()
// │   ├── CalculateLauncherAngleToTarget()
// │   └── CalculateVirtualTarget()
// │
// ├── Coordinate Transformations
// │   ├── GetLauncherWorldPosition()
// │   ├── GetChassisPose()
// │   └── GetChassisVelocity()
// │
// └── Configuration (Virtual - Overridden in Subclasses)
//     ├── SetLauncherOffset()
//     ├── GetLauncherOffset()
//     └── GetTargetPosition()
//
// RebuiltTargetCalculator (Season-Specific Subclass)
// ├── GetTargetPosition()      [Hardcoded hub for testing]
// ├── SetLauncherOffset()      [Configure launcher position]
// └── GetLauncherOffset()      [Query launcher position]
//
// TODO: When FieldElementCalculator and ZoneCalculator are available:
// - Update GetTargetPosition() to query field element positions
// - Add dynamic zone detection and target selection
//
//====================================================================================================================================================
// BASIC USAGE EXAMPLES
//====================================================================================================================================================
//
// Example 1: Simple Distance and Angle Calculation
// ================================================
//
//     #include "utils/RebuiltTargetCalculator.h"
//     #include <units/length.h>
//     
//     void MyCommand::Execute()
//     {
//         auto targetCalc = RebuiltTargetCalculator::GetInstance();
//         
//         // Get distance to current target (from chassis center)
//         auto distance = targetCalc->CalculateDistanceToTarget();
//         
//         // Get angle to current target (in robot frame)
//         // 0° = forward, 90° = left, -90° = right
//         auto angle = targetCalc->CalculateAngleToTarget();
//         
//         printf("Distance: %.2f meters, Angle: %.1f degrees\n", 
//                distance.value(), angle.value());
//     }
//
//
// Example 2: Using Launcher Offset
// =================================
//
//     void InitSubsystemsCommand::Initialize()
//     {
//         auto targetCalc = RebuiltTargetCalculator::GetInstance();
//         
//         // Set launcher position relative to robot center
//         // Robot: +X = forward, +Y = left
//         targetCalc->SetLauncherOffset(
//             -0.1397_m,  // 5.5 inches back (-X)
//             0_m         // Centered (-Y)
//         );
//     }
//     
//     void MyCommand::Execute()
//     {
//         auto targetCalc = RebuiltTargetCalculator::GetInstance();
//         
//         // Get distance from launcher (not chassis center) to target
//         auto distance = targetCalc->CalculateLauncherDistanceToTarget();
//         
//         // Get angle from launcher to target
//         auto angle = targetCalc->CalculateLauncherAngleToTarget();
//     }
//
//
// Example 3: Dynamic Target Selection
// ====================================
//
//     void ZoneDetectionCommand::Execute()
//     {
//         auto targetCalc = RebuiltTargetCalculator::GetInstance();
//         
//         // TODO: Implement zone detection based on chassis position
//         // Once FieldElementCalculator and ZoneCalculator are available:
//         // - Determine current zone from robot position
//         // - Query FieldElementCalculator for zone-specific targets
//         // - Update GetTargetPosition() to return appropriate target
//         
//         auto distance = targetCalc->CalculateDistanceToTarget();
//         auto angle = targetCalc->CalculateAngleToTarget();
//     }
//
//
// Example 4: Virtual Target for Moving Robot
// ===========================================
//
//     void ShootingCommand::Execute()
//     {
//         auto targetCalc = RebuiltTargetCalculator::GetInstance();
//         
//         // Get the real target position
//         auto realTarget = targetCalc->GetTargetPosition();
//         
//         // Calculate virtual target accounting for robot movement
//         // Lookahead time = expected projectile flight time
//         auto virtualTarget = targetCalc->CalculateVirtualTarget(
//             realTarget,
//             1.0_s  // 1 second flight time
//         );
//         
//         // Calculate angle to virtual target
//         auto angleToVirtual = targetCalc->CalculateAngleToTarget(&virtualTarget);
//         
//         // Use this angle for aiming instead of the real target
//         SetLauncherAngle(angleToVirtual);
//     }
//
//====================================================================================================================================================
// COORDINATE SYSTEMS
//====================================================================================================================================================
//
// World Frame (Field Frame)
// ========================
// Used for all target positions and chassis pose
// - +X axis points along the field length (forward)
// - +Y axis points across the field width (left)
// - 0° rotation points along +X axis (right)
// - Positions in meters, angles in radians
//
// Robot Frame
// ===========
// Used for calculated angles to targets
// - +X points forward (direction robot's bumper faces)
// - +Y points left (relative to robot's forward direction)
// - 0° = forward, 90° = left, -90° = right, 180° = backward
// - Angles in degrees for readability
//
// Launcher/Mechanism Frame
// ========================
// Offset from robot center, defined in robot coordinates
// Default: (-0.1397m, 0m) = 5.5 inches back, centered left-right
// Can be configured per mechanism type
//
//====================================================================================================================================================
// VIRTUAL TARGET COMPENSATION
//====================================================================================================================================================
//
// The virtual target calculation compensates for the robot's movement while a projectile
// is in flight. This is critical for scoring on a moving robot.
//
// Basic Principle:
// ================
// If the robot is moving toward the target, the target appears to move away from the
// robot's reference frame. To compensate, we aim at a virtual target closer than the
// real target. Conversely, if moving away, we aim farther.
//
// Formula:
// ========
// VirtualTarget = RealTarget - (Velocity × Lookahead Time)
//
// Where:
// - RealTarget: Actual scoring location in world frame
// - Velocity: Robot velocity in world frame (m/s)
// - Lookahead Time: Expected projectile flight time (seconds)
//
// Examples:
// =========
// Scenario: Robot moving forward at 1.25 m/s, real target is 4 meters away
//
// Lookahead Time = 0.5 seconds (fast shot):
//   Offset = 1.25 m/s × 0.5s = 0.625 meters
//   Virtual target is 0.625m closer (less compensation)
//
// Lookahead Time = 1.0 seconds (medium flight):
//   Offset = 1.25 m/s × 1.0s = 1.25 meters
//   Virtual target is 1.25m closer (medium compensation)
//
// Lookahead Time = 2.0 seconds (slow/arcing shot):
//   Offset = 1.25 m/s × 2.0s = 2.5 meters
//   Virtual target is 2.5m closer (more compensation)
//
// Tuning Tips:
// ============
// 1. If shooting from a stationary robot works but moving doesn't, increase lookahead time
// 2. If overshooting when moving forward, increase lookahead time
// 3. If undershooting when moving forward, decrease lookahead time
// 4. Consider different lookahead times for different shot types:
//    - Direct shots: 0.3-0.5 seconds
//    - Lob shots: 1.0-2.0 seconds
//
//====================================================================================================================================================
// LAUNCHER OFFSET CONFIGURATION
//====================================================================================================================================================
//
// The launcher offset defines where the mechanism is located relative to the robot's
// geometric center. This is crucial for accurate angle/distance calculations.
//
// Default Configuration:
// ======================
// SetLauncherOffset(-0.1397_m, 0_m)  // 5.5 inches back, centered
//
// Common Configurations for Different Mechanisms:
// ===============================================
//
// Center-mounted shooter:
//   SetLauncherOffset(0_m, 0_m)
//
// Rear-mounted shooter (5.5 inches back):
//   SetLauncherOffset(-0.1397_m, 0_m)
//
// Left-side mounted shooter:
//   SetLauncherOffset(0_m, 0.2_m)
//
// Intake at front:
//   SetLauncherOffset(0.2_m, 0_m)
//
// Note: Reconfigure before each match or between mechanisms!
//
//====================================================================================================================================================
// EXTENDING FOR NEW MECHANISMS
//====================================================================================================================================================
//
// To create a new calculator for a different mechanism or season:
//
// 1. Create a new subclass of TargetCalculator
// 2. Override GetTargetPosition() to define your targets
// 3. Override SetLauncherOffset() and GetLauncherOffset() for mechanism configuration
// 4. Add mechanism-specific methods (speed calculations, etc.)
//
// Example:
// ========
//
// class IntakePieceTargetCalculator : public TargetCalculator {
// public:
//     static IntakePieceTargetCalculator* GetInstance();
//     
//     frc::Translation2d GetTargetPosition() override;
//     void SetLauncherOffset(units::meter_t xOffset, units::meter_t yOffset) override;
//     frc::Translation2d GetLauncherOffset() const override;
//     
// private:
//     IntakePieceTargetCalculator();
//     static IntakePieceTargetCalculator* m_instance;
//     
//     // Custom intake targets
//     frc::Translation2d m_intakePieceTarget{...};
//     frc::Translation2d m_launcherOffset{0_m, 0_m};
// };
//
// Note: GetTargetPosition() is non-const to allow dynamic target selection
// based on chassis position, zone, or other factors.
//
//====================================================================================================================================================
// PERFORMANCE CONSIDERATIONS
//====================================================================================================================================================
//
// - All calculations are O(1) time complexity
// - No allocations in main calculation loops
// - Safe to call every loop cycle without performance penalty
// - Chassis pose/velocity are queried directly from subsystem
// - Consider caching results if called multiple times per loop
//
// Example Caching:
// ================
//
//     class MyCommand {
//     private:
//         units::meter_t m_cachedDistance;
//         units::degree_t m_cachedAngle;
//     
//         void CacheTargetInfo() {
//             auto targetCalc = GamePieceTargetCalculator::GetInstance();
//             m_cachedDistance = targetCalc->CalculateLauncherDistanceToTarget();
//             m_cachedAngle = targetCalc->CalculateLauncherAngleToTarget();
//         }
//     };
//
//====================================================================================================================================================
